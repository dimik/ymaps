#!/usr/bin/env python
# coding: utf-8

#
# Logentries agent <https://logentries.com/>.
# This work is licensed under a <http://creativecommons.org/licenses/by/3.0/> Creative Commons Attribution 3.0 Unported License
#

import os
#
# Constants
#

VERSION = "1.2.4"

NOT_SET = None

# Default user and agent keys of none are defined in configuration
DEFAULT_USER_KEY = NOT_SET
DEFAULT_AGENT_KEY = NOT_SET

# Configuration files
#CONFIG_DIR_SYSTEM = '${OPENSHIFT_DATA_DIR}'
#CONFIG_DIR_USER = '.le'
OPENSHIFT_DATA_DIR = os.getenv('OPENSHIFT_DATA_DIR')
LE_CONFIG = 'config'
LE_CERT_NAME = 'ca-certs.pem'
PID_FILE = OPENSHIFT_DATA_DIR + 'logentries.pid'

MAIN_SECT = 'Main'
USER_KEY_PARAM = 'user-key'
AGENT_KEY_PARAM = 'agent-key'
FILTERS_PARAM = 'filters'
EC2EU_PARAM = 'ec2eu'
SUPPRESS_SSL_PARAM = 'suppress_ssl'
KEY_LEN = 36
USER_KEY_API = '/agent/user-key/'
ID_LOGS_API = '/agent/id-logs/'

# Logentries server details
LE_SERVER = 'logentries.com'
LE_SERVER_L = 'localhost:8000'
LE_SERVER_API_DOMAIN = 'api.logentries.com'
LE_SERVER_EC2EU_API_DOMAIN = 'ec2eu.api.logentries.com'
LE_SERVER_API_DOMAIN_L = 'localhost:8081'
LE_SERVER_CONFIG = '/agent/config'
LE_SERVER_LOGIN = '/login/'
LE_SERVER_API = '/'
LE_SERVER_PORT = 443

CONTENT_LENGTH = 'content-length';

# Windows event log type ID
WINEVENT_LOGTYPE = '9c0912b7-674b-47f1-89ac-eed5aa3affe0'

# URL to detect EC2 availability zone
EC2_AVZ_URL = 'http://169.254.169.254/latest/meta-data/placement/availability-zone'
EC2_AVZ_EU_PREFIX = 'eu-west-1'

# Log root directory
LOG_ROOT = '/var/log'

# Timeout after server connection fail. Might be a temporary network
# failure.
SRV_RECON_TIMEOUT=10 # in seconds

# Timeout after invalid server response. Might be a version mishmash or
# temporary server/network failure
INV_SRV_RESP_TIMEOUT=30 # Seconds

# Time interval between re-trying to open log file
REOPEN_TRY_INTERVAL=1 # Seconds

# Number of lines which can be sent in one buck, piggybacking
MAX_LINES_SENT=10

# Time in seconds spend between log re-checks
TAIL_RECHECK = 0.2 # Seconds

# Number of attemps to read a file, until the name is recheck
NAME_CHECK = 4 # TAIL_RECHECK cycles

# Number of read line false attemps between are-you-alive packets
IAA_INTERVAL = 100
IAA_TOKEN = "###LE-IAA###\n"

# Maximal size of a block of events
MAX_EVENTS = 65536

# Interval between attampts to open a file
REOPEN_INT = 1 # Seconds

# Linux block devices
SYS_BLOCK_DEV = '/sys/block/'
# Linux CPU stat file
CPUSTATS_FILE = '/proc/stat'
# Linux mmeory stat file
MEMSTATS_FILE = '/proc/meminfo'
# Linux network stat file
NETSTATS_FILE = '/proc/net/dev'

# List of accepted network devices
NET_DEVICES = [ '  eth', ' wlan', 'venet', ' veth']

EPOCH = 5 # in seconds

# Config response parameters
CONF_RESPONSE = 'response'
CONF_REASON = 'reason'
CONF_LOGS = 'logs'
CONF_SERVERS = 'servers'
CONF_OK = 'ok'

# Server requests
RQ_WORKLOAD = 'push_wl'

# Release information on LSB systems
LSB_RELEASE = '/etc/lsb-release'

# Return codes
EXIT_OK = 0
EXIT_NO = 1
EXIT_ERR = 3
EXIT_HELP = 4


#
# Usage help
#

PULL_USAGE = "pull <path> <when> <filter> <limit>"
PUSH_USAGE = "push <file> <path> <log-type>"
USAGE="Logentries agent version " +VERSION +"""
usage: le COMMAND [ARGS]

Where command is one of:
  init      Write local configuration file
  reinit    As init but does not reset undefined parameters
  register  Register this host
    --name=  name of the host
    --hostname=  hostname of the host
  whoami    Displays settings for this host
  monitor   Monitor this host
  follow <filename>  Follow the given log
    --name=  name of the log
    --type=  type of the log
  followed <filename>  Check if the file is followed
  clean     Removes configuration file
  ls        List internal filesystem and settings: <path>
  rm        Remove entity: <path>
  pull      Pull log file: <path> <when> <filter> <limit>
  push      Push log file: <file> <path> <log-type>

Where parameters are:
  --help            show usage help and exit
  --version         display version number and exit
  --account-key=    set account key and exit
  --host-key=       set local host key and exit, generate key if key is empty
  --no-timestamps   no timestamps in agent reportings
  --force           force given operation
  --ec2eu           assume the host is in EC2 EU region
  --suppress-ssl    do not use SSL with API server
  --yes	            always respond yes
  --force-api-host  use particular host as an api server
"""

WINDOWS_USAGE="""
Windows specific commands:
  windowsevents     follow the Application, System and Security win event logs 
  windowsevents <eventlog>  follow the windows event log specified 
  installwinservice	installs the agent as a windows service 
	--no-defaults   do not follow standard windows logs automatically
  monitorwinservice	starts monitoring as a windows service
"""


# Global indicator of monitoring interruption
shutdown = False

def set_shutdown():
	global shutdown
	shutdown = True
	print >>sys.stderr, "Shutting down"

def report( what):
	print >>sys.stderr, what

def print_usage( version_only=False):
	if version_only:
		report( VERSION)
	else:
		report( USAGE)

		if os.name != "posix":
			report( WINDOWS_USAGE)
		
	sys.exit( EXIT_HELP)


#
# Authority certificate
#
# Used if not provided by the underlying system
#

authority_certificate = """-----BEGIN CERTIFICATE-----
MIIDIDCCAomgAwIBAgIENd70zzANBgkqhkiG9w0BAQUFADBOMQswCQYDVQQGEwJV
UzEQMA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2Vy
dGlmaWNhdGUgQXV0aG9yaXR5MB4XDTk4MDgyMjE2NDE1MVoXDTE4MDgyMjE2NDE1
MVowTjELMAkGA1UEBhMCVVMxEDAOBgNVBAoTB0VxdWlmYXgxLTArBgNVBAsTJEVx
dWlmYXggU2VjdXJlIENlcnRpZmljYXRlIEF1dGhvcml0eTCBnzANBgkqhkiG9w0B
AQEFAAOBjQAwgYkCgYEAwV2xWGcIYu6gmi0fCG2RFGiYCh7+2gRvE4RiIcPRfM6f
BeC4AfBONOziipUEZKzxa1NfBbPLZ4C/QgKO/t0BCezhABRP/PvwDN1Dulsr4R+A
cJkVV5MW8Q+XarfCaCMczE1ZMKxRHjuvK9buY0V7xdlfUNLjUA86iOe/FP3gx7kC
AwEAAaOCAQkwggEFMHAGA1UdHwRpMGcwZaBjoGGkXzBdMQswCQYDVQQGEwJVUzEQ
MA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2VydGlm
aWNhdGUgQXV0aG9yaXR5MQ0wCwYDVQQDEwRDUkwxMBoGA1UdEAQTMBGBDzIwMTgw
ODIyMTY0MTUxWjALBgNVHQ8EBAMCAQYwHwYDVR0jBBgwFoAUSOZo+SvSspXXR9gj
IBBPM5iQn9QwHQYDVR0OBBYEFEjmaPkr0rKV10fYIyAQTzOYkJ/UMAwGA1UdEwQF
MAMBAf8wGgYJKoZIhvZ9B0EABA0wCxsFVjMuMGMDAgbAMA0GCSqGSIb3DQEBBQUA
A4GBAFjOKer89961zgK5F7WF0bnj4JXMJTENAKaSbn+2kmOeUJXRmm/kEd5jhW6Y
7qj/WsjTVbJmcVfewCHrPSqnI0kBBIZCe/zuf6IWUrVnZ9NA2zsmWLIodz2uFHdh
1voqZiegDfqnc1zqcPGUIWVEX/r87yloqaKHee9570+sB3c4
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDVDCCAjygAwIBAgIDAjRWMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMDIwNTIxMDQwMDAwWhcNMjIwNTIxMDQwMDAwWjBCMQswCQYDVQQG
EwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEbMBkGA1UEAxMSR2VvVHJ1c3Qg
R2xvYmFsIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2swYYzD9
9BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEHCIjaWC9mOSm9BXiLnTjoBbdq
fnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIuT8rxh0PBFpVXLVDv
iS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6cJmTM386DGXHKTubU
1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmRCw7+OC7RHQWa9k0+
bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5aszPeE4uwc2hGKceeoW
MPRfwCvocWvk+QIDAQABo1MwUTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTA
ephojYn7qwVkDBF9qn1luMrMTjAfBgNVHSMEGDAWgBTAephojYn7qwVkDBF9qn1l
uMrMTjANBgkqhkiG9w0BAQUFAAOCAQEANeMpauUvXVSOKVCUn5kaFOSPeCpilKIn
Z57QzxpeR+nBsqTP3UEaBU6bS+5Kb1VSsyShNwrrZHYqLizz/Tt1kL/6cdjHPTfS
tQWVYrmm3ok9Nns4d0iXrKYgjy6myQzCsplFAMfOEVEiIuCl6rYVSAlk6l5PdPcF
PseKUgzbFbS9bZvlxrFUaKnjaZC2mqUPuLk/IH2uSrW4nOQdtqvmlKXBx4Ot2/Un
hw4EbNX/3aBd7YdStysVAq45pmp06drE57xNNB6pXE0zX5IJL4hmXXeXxx12E6nV
5fEWCRE11azbJHFwLJhWC9kXtNHjUStedejV0NxPNO3CBWaAocvmMw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID2TCCAsGgAwIBAgIDAjbQMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTAwMjE5MjIzOTI2WhcNMjAwMjE4MjIzOTI2WjBAMQswCQYDVQQG
EwJVUzEXMBUGA1UEChMOR2VvVHJ1c3QsIEluYy4xGDAWBgNVBAMTD0dlb1RydXN0
IFNTTCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJCzgMHk5Uat
cGA9uuUU3Z6KXot1WubKbUGlI+g5hSZ6p1V3mkihkn46HhrxJ6ujTDnMyz1Hr4Gu
FmpcN+9FQf37mpc8oEOdxt8XIdGKolbCA0mEEoE+yQpUYGa5jFTk+eb5lPHgX3UR
8im55IaisYmtph6DKWOy8FQchQt65+EuDa+kvc3nsVrXjAVaDktzKIt1XTTYdwvh
dGLicTBi2LyKBeUxY0pUiWozeKdOVSQdl+8a5BLGDzAYtDRN4dgjOyFbLTAZJQ50
96QhS6CkIMlszZhWwPKoXz4mdaAN+DaIiixafWcwqQ/RmXAueOFRJq9VeiS+jDkN
d53eAsMMvR8CAwEAAaOB2TCB1jAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFEJ5
VBthzVUrPmPVPEhX9Z/7Rc5KMB8GA1UdIwQYMBaAFMB6mGiNifurBWQMEX2qfWW4
ysxOMBIGA1UdEwEB/wQIMAYBAf8CAQAwOgYDVR0fBDMwMTAvoC2gK4YpaHR0cDov
L2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwNAYIKwYBBQUHAQEE
KDAmMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5nZW90cnVzdC5jb20wDQYJKoZI
hvcNAQEFBQADggEBANTvU4ToGr2hiwTAqfVfoRB4RV2yV2pOJMtlTjGXkZrUJPji
J2ZwMZzBYlQG55cdOprApClICq8kx6jEmlTBfEx4TCtoLF0XplR4TEbigMMfOHES
0tdT41SFULgCy+5jOvhWiU1Vuy7AyBh3hjELC3DwfjWDpCoTZFZnNF0WX3OsewYk
2k9QbSqr0E1TQcKOu3EDSSmGGM8hQkx0YlEVxW+o78Qn5Rsz3VqI138S0adhJR/V
4NwdzxoQ2KDLX4z6DOW/cf/lXUQdpj6HR/oaToODEj+IZpWYeZqF6wJHzSXj8gYE
TpnKXKBuervdo5AaRTPvvz7SBMS24CqFZUE+ENQ=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDfTCCAuagAwIBAgIDErvmMA0GCSqGSIb3DQEBBQUAME4xCzAJBgNVBAYTAlVT
MRAwDgYDVQQKEwdFcXVpZmF4MS0wKwYDVQQLEyRFcXVpZmF4IFNlY3VyZSBDZXJ0
aWZpY2F0ZSBBdXRob3JpdHkwHhcNMDIwNTIxMDQwMDAwWhcNMTgwODIxMDQwMDAw
WjBCMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEbMBkGA1UE
AxMSR2VvVHJ1c3QgR2xvYmFsIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEA2swYYzD99BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEHCIjaWC9m
OSm9BXiLnTjoBbdqfnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIu
T8rxh0PBFpVXLVDviS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6c
JmTM386DGXHKTubU1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmR
Cw7+OC7RHQWa9k0+bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5asz
PeE4uwc2hGKceeoWMPRfwCvocWvk+QIDAQABo4HwMIHtMB8GA1UdIwQYMBaAFEjm
aPkr0rKV10fYIyAQTzOYkJ/UMB0GA1UdDgQWBBTAephojYn7qwVkDBF9qn1luMrM
TjAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjA6BgNVHR8EMzAxMC+g
LaArhilodHRwOi8vY3JsLmdlb3RydXN0LmNvbS9jcmxzL3NlY3VyZWNhLmNybDBO
BgNVHSAERzBFMEMGBFUdIAAwOzA5BggrBgEFBQcCARYtaHR0cHM6Ly93d3cuZ2Vv
dHJ1c3QuY29tL3Jlc291cmNlcy9yZXBvc2l0b3J5MA0GCSqGSIb3DQEBBQUAA4GB
AHbhEm5OSxYShjAGsoEIz/AIx8dxfmbuwu3UOx//8PDITtZDOLC5MH0Y0FWDomrL
NhGc6Ehmo21/uBPUR/6LWlxz/K7ZGzIZOKuXNBSqltLroxwUCEm2u+WR74M26x1W
b8ravHNjkOR/ez4iyz0H7V84dJzjA1BOoa+Y7mHyhD8S
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFSjCCBDKgAwIBAgIDBQMSMA0GCSqGSIb3DQEBBQUAMGExCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMR0wGwYDVQQLExREb21haW4gVmFsaWRh
dGVkIFNTTDEbMBkGA1UEAxMSR2VvVHJ1c3QgRFYgU1NMIENBMB4XDTEyMDkxMDE5
NTI1N1oXDTE2MDkxMTIxMjgyOFowgcExKTAnBgNVBAUTIEpxd2ViV3RxdzZNblVM
ek1pSzNiL21hdktiWjd4bEdjMRMwEQYDVQQLEwpHVDAzOTM4NjcwMTEwLwYDVQQL
EyhTZWUgd3d3Lmdlb3RydXN0LmNvbS9yZXNvdXJjZXMvY3BzIChjKTEyMS8wLQYD
VQQLEyZEb21haW4gQ29udHJvbCBWYWxpZGF0ZWQgLSBRdWlja1NTTChSKTEbMBkG
A1UEAxMSYXBpLmxvZ2VudHJpZXMuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAxcmFqgE2p6+N9lM2GJhe8bNUO0qmcw8oHUVrsneeVA66hj+qKPoJ
AhGKxC0K9JFMyIzgPu6FvuVLahFZwv2wkbjXKZLIOAC4o6tuVb4oOOUBrmpvzGtL
kKVN+sip1U7tlInGjtCfTMWNiwC4G9+GvJ7xORgDpaAZJUmK+4pAfG8j6raWgPGl
JXo2hRtOUwmBBkCPqCZQ1mRETDT6tBuSAoLE1UMlxWvMtXCUzeV78H+2YrIDxn/W
xd+eEvGTSXRb/Q2YQBMqv8QpAlarcda3WMWj8pkS38awyBM47GddwVYBn5ZLEu/P
DiRQGSmLQyFuk5GUdApSyFETPL6p9MfV4wIDAQABo4IBqDCCAaQwHwYDVR0jBBgw
FoAUjPTZkwpHvACgSs5LdW6gtrCyfvwwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQW
MBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNVHREEFjAUghJhcGkubG9nZW50cmll
cy5jb20wQQYDVR0fBDowODA2oDSgMoYwaHR0cDovL2d0c3NsZHYtY3JsLmdlb3Ry
dXN0LmNvbS9jcmxzL2d0c3NsZHYuY3JsMB0GA1UdDgQWBBRaMeKDGSFaz8Kvj+To
j7eMOtT/zTAMBgNVHRMBAf8EAjAAMHUGCCsGAQUFBwEBBGkwZzAsBggrBgEFBQcw
AYYgaHR0cDovL2d0c3NsZHYtb2NzcC5nZW90cnVzdC5jb20wNwYIKwYBBQUHMAKG
K2h0dHA6Ly9ndHNzbGR2LWFpYS5nZW90cnVzdC5jb20vZ3Rzc2xkdi5jcnQwTAYD
VR0gBEUwQzBBBgpghkgBhvhFAQc2MDMwMQYIKwYBBQUHAgEWJWh0dHA6Ly93d3cu
Z2VvdHJ1c3QuY29tL3Jlc291cmNlcy9jcHMwDQYJKoZIhvcNAQEFBQADggEBAAo0
rOkIeIDrhDYN8o95+6Y0QhVCbcP2GcoeTWu+ejC6I9gVzPFcwdY6Dj+T8q9I1WeS
VeVMNtwJt26XXGAk1UY9QOklTH3koA99oNY3ARcpqG/QwYcwaLbFrB1/JkCGcK1+
Ag3GE3dIzAGfRXq8fC9SrKia+PCdDgNIAFqe+kpa685voTTJ9xXvNh7oDoVM2aip
v1xy+6OfZyGudXhXag82LOfiUgU7hp+RfyUG2KXhIRzhMtDOHpyBjGnVLB0bGYcC
566Nbe7Alh38TT7upl/O5lA29EoSkngtUWhUnzyqYmEMpay8yZIV4R9AuUk2Y4HB
kAuBvDPPm+C0/M4RLYs=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID+jCCAuKgAwIBAgIDAjbSMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTAwMjI2MjEzMjMxWhcNMjAwMjI1MjEzMjMxWjBhMQswCQYDVQQG
EwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjEdMBsGA1UECxMURG9tYWluIFZh
bGlkYXRlZCBTU0wxGzAZBgNVBAMTEkdlb1RydXN0IERWIFNTTCBDQTCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAKa7jnrNpJxiV9RRMEJ7ixqy0ogGrTs8
KRMMMbxp+Z9alNoGuqwkBJ7O1KrESGAA+DSuoZOv3gR+zfhcIlINVlPrqZTP+3RE
60OUpJd6QFc1tqRi2tVI+Hrx7JC1Xzn+Y3JwyBKF0KUuhhNAbOtsTdJU/V8+Jh9m
cajAuIWe9fV1j9qRTonjynh0MF8VCpmnyoM6djVI0NyLGiJOhaRO+kltK3C+jgwh
w2LMpNGtFmuae8tk/426QsMmqhV4aJzs9mvIDFcN5TgH02pXA50gDkvEe4GwKhz1
SupKmEn+Als9AxSQKH6a9HjQMYRX5Uw4ekIR4vUoUQNLIBW7Ihq28BUCAwEAAaOB
2TCB1jAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFIz02ZMKR7wAoErOS3VuoLaw
sn78MB8GA1UdIwQYMBaAFMB6mGiNifurBWQMEX2qfWW4ysxOMBIGA1UdEwEB/wQI
MAYBAf8CAQAwOgYDVR0fBDMwMTAvoC2gK4YpaHR0cDovL2NybC5nZW90cnVzdC5j
b20vY3Jscy9ndGdsb2JhbC5jcmwwNAYIKwYBBQUHAQEEKDAmMCQGCCsGAQUFBzAB
hhhodHRwOi8vb2NzcC5nZW90cnVzdC5jb20wDQYJKoZIhvcNAQEFBQADggEBADOR
NxHbQPnejLICiHevYyHBrbAN+qB4VqOC/btJXxRtyNxflNoRZnwekcW22G1PqvK/
ISh+UqKSeAhhaSH+LeyCGIT0043FiruKzF3mo7bMbq1vsw5h7onOEzRPSVX1ObuZ
lvD16lo8nBa9AlPwKg5BbuvvnvdwNs2AKnbIh+PrI7OWLOYdlF8cpOLNJDErBjgy
YWE5XIlMSB1CyWee0r9Y9/k3MbBn3Y0mNhp4GgkZPJMHcCrhfCn13mZXCxJeFu1e
vTezMGnGkqX2Gdgd+DYSuUuVlZzQzmwwpxb79k1ktl8qFJymyFWOIPllByTMOAVM
IIi0tWeUz12OYjf+xLQ=
-----END CERTIFICATE-----
"""
authority_certificate_files = [
	# Debian 5.0, Debian 6.0, Ubuntu 9.10, Ubuntu 10.4
	"/etc/ssl/certs/ca-certificates.crt",
	# Fedora 12, Fedora 13, CentOS 5
	"/usr/share/purple/ca-certs/GeoTrust_Global_CA.pem",
	# Amazon AMI
	"/etc/pki/tls/certs/ca-bundle.crt",
	]


#
# Libraries
#

import string
import re
import errno
import ConfigParser
import fileinput
import getopt
import glob
import logging
#import os
import platform
import socket
import subprocess
import sys
import threading
import time
import datetime
import urllib
import urllib2
import httplib
import getpass
import atexit


#
# Start logging
#

log = logging.getLogger( LE_SERVER)
if not log:
	report( "Cannot open log output")
	sys.exit( EXIT_ERR)

stream_handler = None

log.setLevel( logging.INFO)

stream_handler = logging.StreamHandler()
stream_handler.setLevel( logging.DEBUG)
stream_handler.setFormatter( logging.Formatter( "%(message)s"))
log.addHandler( stream_handler)



def die(cause, exit_code=EXIT_ERR):
	log.critical( cause)
	sys.exit( exit_code)


#
# Imports that may not be available
#

try:
	import json
	try:
		json_loads = json.loads
		json_dumps = json.dumps
	except AttributeError:
		json_loads = json.read
		json_dumps = json.write
except ImportError:
	try: import simplejson
	except ImportError: die( 'NOTE: Please install Python "simplejson" package (python-simplejson) or a newer Python (2.6).')
	json_loads = simplejson.loads
	json_dumps = simplejson.dumps


no_ssl = False
try:
	import ssl
	wrap_socket = ssl.wrap_socket
	CERT_REQUIRED = ssl.CERT_REQUIRED

except ImportError:
	no_ssl = True

	try: x = httplib.HTTPSConnection
	except AttributeError:
		die( 'NOTE: Please install Python "ssl" module.')

	log.warning( '\nWarning: Not verifying cetrificates since the "ssl" module is not present. Install "ssl" module or newer Python (>=2.6) to avoid this message.')

	def wrap_socket( sock, ca_certs=None, cert_reqs=None):
		return socket.ssl( sock)
	CERT_REQUIRED = 0

#
# Custom proctitle
#

def set_proc_title(title):
	try:
		import setproctitle
		setproctitle.setproctitle(title)
	except ImportError: pass


#
# User-defined filtering code
#

def filter_events( events):
	"""
	User-defined filtering code. Events passed are about to be sent to
	logentries server. Make the required modifications to the events such
	as removing unvanted or sensitive information.
	"""
	# By default, this method is empty
	return events
	

def call( command):
	"""
	Calls the given command in OS environment.
	"""
	x = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True).stdout.read()
	if len(x) == 0: return ''
	if x[-1] == '\n': x = x[0:len(x)-1]
	return x


def is_uuid( x):
	"""
	Returns true if the string given appears to be UUID.
	"""
	return re.match( r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', x)


def uniq(arr):
    """
    Returns the list with duplicate elements removed.
    """
    return list( set( arr))


def rfile( name):
	"""
	Returns content of the file, without trailing newline.
	"""
	x = open( name).read()
	if len(x) != 0 and x[-1] == '\n': x = x[0:len(x)-1]
	return x


def rm_pidfile():
	"""
	Removes PID file. Calles when the agent exits.
	"""
	try:
		if config.pid_file:
			os.remove( config.pid_file)
	except OSError:
		pass


def daemonize():
	"""
	Creates a daemon from the current process.
	http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/
	Alternative: python-daemon
	"""
	try:
		# Open pid file
		if config.pid_file:
			file( config.pid_file, 'w').close()

		pid = os.fork()
		if pid > 0:
			sys.exit( EXIT_OK)
		os.chdir( "/")
		os.setsid()
		os.umask( 0)
		pid = os.fork()
		if pid > 0:
			sys.exit( EXIT_OK)
		sys.stdout.flush()
		sys.stderr.flush()
		si = file( '/dev/null', 'r')
		so = file( '/dev/null', 'a+')
		se = file( '/dev/null', 'a+', 0)
		os.dup2( si.fileno(), sys.stdin.fileno())
		os.dup2( so.fileno(), sys.stdout.fileno())
		os.dup2( se.fileno(), sys.stderr.fileno())

		# Write pid file
		if config.pid_file:
			pid = str( os.getpid())
			pidfile = file( config.pid_file, 'w')
			atexit.register( rm_pidfile)
			pidfile.write( "%s\n"%pid)
			pidfile.close()
	except OSError, e:
		rm_pidfile()
		die( "Cannot daemonize: %s"%e.strerror)

	# Setting the proctitle
	set_proc_title('logentries-daemon')

	# Logging for daemon mode
	log.removeHandler( stream_handler)
	shandler = logging.StreamHandler()
	shandler.setLevel( logging.DEBUG)
	shandler.setFormatter( logging.Formatter( "%(asctime)s  %(message)s"))
	log.addHandler( shandler)



def print_total( elems, name):
	"""
	Prints total number of elements in the list
	"""
	total = len( elems)
	if total == 0:
		report( "no %ss"%name)
	elif total == 1:
		report( "1 "+name)
	else:
		report( "%d %ss"%(total,name))


def collect_log_names( system_info):
	"""
	Collects standard local logs and identifies them.
	"""
	logs = []
	for root, dirs, files in os.walk(LOG_ROOT):
		for name in files:
			if name[-3:] != '.gz' and re.match( r'.*\.\d+$', name) == None:
				logs.append( os.path.join(root, name))
	
	log.debug( "Collected logs: %s"%logs)
	try:
		c = httplib.HTTPSConnection( LE_SERVER_API)
		request = {
			'logs': json_dumps(logs),
			'distname': system_info['distname'],
			'distver': system_info['distver']
			}
		log.debug( "Requesting %s"%request)
		c.request( 'post', ID_LOGS_API, urllib.urlencode( request), {})
		response = c.getresponse()
		if not response or response.status != 200:
			die( 'Error: Unexpected response from logentries (%s).'%response.status)
		data = json_loads( response.read())
		log_data = data['logs']

		log.debug( "Identified logs: %s"%log_data)
	except socket.error, msg:
		die( 'Error: Cannot contact server, %s'%msg)
	except ValueError, msg:
		die( 'Error: Invalid response from the server (Parsing error %s)'%msg)
	except KeyError:
		die( 'Error: Invalid response from the server, log data not present.')
	
	return log_data

def lsb_release( system_info):
	# General LSB system
	if os.path.isfile( LSB_RELEASE):
		try:
			fields = dict( (a.split('=') for a in rfile( LSB_RELEASE).split('\n') if len(a.split('='))==2))
			system_info[ 'distname'] = fields[ 'DISTRIB_ID']
			system_info[ 'distver'] = fields[ 'DISTRIB_RELEASE']
			return True
		except ValueError:
			pass
		except KeyError:
			pass
	
	# Information not found
	return False

def release_test( filename, distname, system_info):
	if os.path.isfile( filename):
		system_info[ 'distname'] = distname
		system_info[ 'distver'] = rfile( filename)
		return True
	return False


def system_detect( details):
	"""
	Detects the current operating system. Returned information contains:

	distname: distribution name
	distver: distribution version
	kernel: kernel type
	system: system name
	hostname: host name
	"""
	uname = platform.uname()
	sys = uname[0]
	system_info = dict( system=sys, hostname=socket.getfqdn(),
		kernel='', distname='', distver='')

	if not details: return system_info

	if sys == "SunOS":
		pass
	elif sys == "AIX":
		system_info[ 'distver'] = call( "oslevel -r")
	elif sys == "Linux":
		system_info[ 'kernel'] = uname[2]
		# XXX CentOS?
		releases = [
			['/etc/debian_version', 'Debian'],
			['/etc/UnitedLinux-release', 'United Linux'],
			['/etc/annvix-release', 'Annvix'],
			['/etc/arch-release', 'Arch Linux'],
			['/etc/arklinux-release', 'Arklinux'],
			['/etc/aurox-release', 'Aurox Linux'],
			['/etc/blackcat-release', 'BlackCat'],
			['/etc/cobalt-release', 'Cobalt'],
			['/etc/conectiva-release', 'Conectiva'],
			['/etc/fedora-release', 'Fedora Core'],
			['/etc/gentoo-release', 'Gentoo Linux'],
			['/etc/immunix-release', 'Immunix'],
			['/etc/knoppix_version', 'Knoppix'],
			['/etc/lfs-release', 'Linux-From-Scratch'],
			['/etc/linuxppc-release', 'Linux-PPC'],
			['/etc/mandriva-release', 'Mandriva Linux'],
			['/etc/mandrake-release', 'Mandrake Linux'],
			['/etc/mandakelinux-release', 'Mandrake Linux'],
			['/etc/mklinux-release', 'MkLinux'],
			['/etc/nld-release', 'Novell Linux Desktop'],
			['/etc/pld-release', 'PLD Linux'],
			['/etc/redhat-release', 'Red Hat'],
			['/etc/slackware-version', 'Slackware'],
			['/etc/e-smith-release', 'SME Server'],
			['/etc/release', 'Solaris SPARC'],
			['/etc/sun-release', 'Sun JDS'],
			['/etc/SuSE-release', 'SuSE'],
			['/etc/sles-release', 'SuSE Linux ES9'],
			['/etc/tinysofa-release', 'Tiny Sofa'],
			['/etc/turbolinux-release', 'TurboLinux'],
			['/etc/ultrapenguin-release', 'UltraPenguin'],
			['/etc/va-release', 'VA-Linux/RH-VALE'],
			['/etc/yellowdog-release', 'Yellow Dog'],
			]
		
		# Check for known system IDs
		for release in releases:
			if release_test( release[0], release[1], system_info):
				break
		# Check for general LSB system
		if os.path.isfile( LSB_RELEASE):
			try:
				fields = dict( (a.split('=') for a in rfile( LSB_RELEASE).split('\n') if len(a.split('='))==2))
				system_info[ 'distname'] = fields[ 'DISTRIB_ID']
				system_info[ 'distver'] = fields[ 'DISTRIB_RELEASE']
			except ValueError:
				pass
			except KeyError:
				pass
	return system_info


# Identified ranges

SEC = 1000
MIN = 60*SEC
HOUR = 60*MIN
DAY = 24*HOUR
MON = 31*DAY
YEAR = 365*DAY

def date_patterns():
	""" Generates date patterns of the form [day<->month year?]. """
	for year in [' %Y',' %y']:
		for mon in ['%b','%B','%m']:
			yield ['%%d %s%s'%(mon, year), DAY, []]
			yield ['%s %%d%s'%(mon, year), DAY, []]
	for mon in ['%b','%B']: # Year empty
		yield ['%%d %s'%(mon), DAY, [YEAR]]
		yield ['%s %%d'%(mon), DAY, [YEAR]]
	yield ['%%Y %%d %s'%(mon), DAY, []]
	yield ['%%Y %s %%d'%(mon), DAY, []]
	yield ['%Y %m %d', DAY, []]

def time_patterns( c_cols):
	""" Generates time patterns of the form [hour:min:sec?] including empty time. """
	if c_cols >= 2:
		yield ['%H:%M:%S', SEC, []]
	if c_cols >= 1:
		yield ['%H:%M', MIN, []]
		yield ['%I:%M%p', MIN, []]
	yield ['%I%p', HOUR, []]

def datetime_patterns( c_cols):
	""" Generates combinations of date and time patterns. """
	# Generate dates only
	for d in date_patterns():
		yield d

	# Generate combinations
	for t in time_patterns( c_cols):
		for d in date_patterns():
			yield ['%s %s'%(d[0], t[0]), t[1], d[2]]
			yield ['%s %s'%(t[0], d[0]), t[1], d[2]]
		yield [t[0], t[1], [YEAR, MON, DAY]]

def timestamp_patterns( sample):
	"""
	Generates all timestamp patterns we can handle. It is constructed by generating all possible combinations
	of date, time, day name and zone. The pattern is [day_name? date<->time zone?] plus simple date and time.
	"""
	# All timestamps variations
	day_name = ''
	if len(sample) > 0:
		if sample[0] in string.ascii_letters:
			day_name = '%a '
	c_cols = sample.count( ':')
	for zone in ['',' %Z',' %z']:
		for dt in datetime_patterns( c_cols):
			yield ['%s%s%s'%(day_name, dt[0], zone), dt[1], dt[2]]

def timestamp_group( text):
	"""
	Returns a tuple [timestamp, range] which corresponds to the date and time given. Exists on parse error.
	"""
	timep = re.sub( r' +', ' ', re.sub( r'[-,./]', ' ', text)).strip()
	start_tuple = None
	for p in timestamp_patterns( timep):
		pattern, resolution, filling = p
		try:
			start_tuple = time.strptime( timep, p[0])
			break
		except ValueError:
			pass
	if not start_tuple:
		die( "Error: Date '%s' not recognized"%text)

	today = datetime.date.today()
	# Complete filling
	if YEAR in filling:
		start_tuple.rm_year = today.year
	if MON in filling:
		start_tuple.rm_month = today.month
	if DAY in filling:
		start_tuple.rm_day = today.day
	return [int(time.mktime( start_tuple))*1000, resolution]


def timestamp_range( text):
	""" Identifies range in the text given. Returns -1 if the range has not
	been identified. """

	# Parse range
	m = re.match( r'^(last)?\s*(\d+)?\s*(s|sec|second|m|min|minute|h|hour|d|day|mon|month|y|year)s?$', text.strip())
	if not m:
		return -1
	count = m.group( 2) # Count of time frames
	tf = m.group( 3) # Time frame
	# Get count
	if count: count = int( count)
	else: count = 1
	# Get time frame
	f_groups = [
		[['s', 'sec', 'second'], SEC],
		[['m', 'min', 'minute'], MIN],
		[['h', 'hour'], HOUR],
		[['d', 'day'], DAY],
		[['mon', 'month'], MON],
		[['y', 'year'], YEAR],
	]
	for tg in f_groups:
		if tf in tg[0]:
			return count*tg[1]
	return -1


def parse_timestamp_range( text):
	"""
	Parses the time range given and return start-end pair of timestamps.

	Recognized structures are:
	t|today
	y|yesterday
	last? \d* (m|min|minute|h|hour|d|day|mon|month|y|year) s?
	range
	datetime
	datetime -> range
	datetime -> datetime
	"""

	text = text.strip()
	# No time frame
	if text == '':
		return [0,9223372036854775807]

	# Day spec
	now = datetime.datetime.now()
	if text in ['t', 'today']:
		today = int(time.mktime(datetime.datetime( now.year, now.month, now.day).timetuple()))*1000
		return [today, today+DAY]
	if text in ['y', 'yesterday']:
		yesterday = int(time.mktime((datetime.datetime( now.year, now.month, now.day)-datetime.timedelta(days=1)).timetuple()))*1000
		return [yesterday, yesterday+DAY]

	# Range spec
	parts = text.split( '->')
	r = timestamp_range( parts[0])
	if (r != -1 and len(parts)>1) or len(parts)>2:
		die( "Error: Date and range '%s' has invalid structure"%text)
	if r != -1:
		now = int( time.time()*1000)
		return [now-r, now]

	# Date spec
	start_group = timestamp_group( parts[0])
	start = start_group[0]
	end = start+start_group[1]
	
	if len(parts) > 1:
		end_range = timestamp_range( parts[1])
		if end_range != -1:
			end = start +end_range
		else:
			end_group = timestamp_group( parts[1])
			end = end_group[0]+end_group[1]
	
	return [start,end]


def retrieve_user_key():
	"""
	Retrieves user key from the web server.
	"""
	while True:
		username = raw_input( 'Username: ')
		password = getpass.getpass()

		try:
			c = domain_connect( api=False)

			c.request( 'POST', USER_KEY_API,
				urllib.urlencode( {'username':username,'password':password}),
				{'Referer':'https://logentries.com/login/'})
			response = c.getresponse()
			if not response or response.status != 200:
				resp_val = 'err'
				if response:
					resp_val = response.status
				if resp_val == 403:
					print >>sys.stderr, 'Error: Login failed. Invalid credentials.'
				else:
					print >>sys.stderr, 'Error: Unexpected login response from logentries (%s).'%resp_val
			else:
				data = json_loads( response.read())
				if data['user_key'] == 'invalid':
					print >>sys.stderr, 'Error: Invalid user key.'
				else:
					return data['user_key']
		except socket.error, msg:
			print >>sys.stderr, 'Error: Cannot contact server, %s'%msg
		except ValueError, msg:
			print >>sys.stderr, 'Error: Invalid response from the server (Parsing error %s)'%msg
		except KeyError:
			print >>sys.stderr, 'Error: Invalid response from the server, user key not present.'

		print >>sys.stderr, 'Try to login again, or press Ctrl+C to break'


class Stats:
	"""
	Collects statistics about the system work load.
	"""

	def __init__(self):
		self.timer = None
		self.to_remove = False
		self.first = True

		# Memory fields we are looking for in /proc/meminfo
		self.MEM_FIELDS = [ 'MemTotal:', 'Active:', 'Cached:']
		# Block devices in the system
		all_devices = [os.path.basename(filename) for filename in glob.glob( SYS_BLOCK_DEV+ '/*')]
		# Monitored devices (all devices except loop)
		self.our_devices = frozenset( [device_name for device_name in all_devices if not device_name.startswith("loop") and not device_name.startswith("ram") and not device_name.startswith("md")])

		self.prev_cpu_stats = [ 0, 0, 0, 0, 0, 0, 0];
		self.prev_disk_stats = [ 0, 0];
		self.prev_net_stats = [ 0, 0];

		if not config.debug_nostats:
			self.send_stats()

	def save_data(self,data,name,value):
		"""
		Saves the value under the name given. Negative values
		are set to 0.
		"""
		if value >= 0:
			data[ name] = value
		else:
			data[ name] = 0


	def cpu_stats(self,data):
		"""
		Collects CPU statistics. Virtual ticks are ignored.
		"""
		try:
			for line in fileinput.input([CPUSTATS_FILE]):
				if len(line) < 13:
					continue
				if line.startswith('cpu '):
					raw_stats = [ long(part) for part in line.split()[1:8]]
					break
			fileinput.close()
		except IOError:
			return

		self.save_data( data, 'cu', raw_stats[0] -self.prev_cpu_stats[0])
		self.save_data( data, 'cl', raw_stats[1] -self.prev_cpu_stats[1])
		self.save_data( data, 'cs', raw_stats[2] -self.prev_cpu_stats[2])
		self.save_data( data, 'ci', raw_stats[3] -self.prev_cpu_stats[3])
		self.save_data( data, 'cio', raw_stats[4] -self.prev_cpu_stats[4])
		self.save_data( data, 'cq', raw_stats[5] -self.prev_cpu_stats[5])
		self.save_data( data, 'csq', raw_stats[6] -self.prev_cpu_stats[6])
		self.prev_cpu_stats = raw_stats

	def disk_stats(self,data):
		"""
		Collects disk statistics. Interested in block devices only.
		"""
		reads = 0L
		writes = 0L
		# For all block devices
		for device in self.our_devices:
			try:
				# Read device stats
				f = open( SYS_BLOCK_DEV +device +'/stat', 'r')
				line = f.read()
				f.close()
			except IOError:
				continue

			# Parse device stats
			parts = line.split()
			if len( parts) < 4:
				continue
			reads += long( parts[ 2])
			writes += long( parts[ 4])

		reads *= 512
		writes *= 512
		self.save_data( data, 'dr', reads -self.prev_disk_stats[0])
		self.save_data( data, 'dw', writes -self.prev_disk_stats[1])
		self.prev_disk_stats = [ reads, writes]

	def mem_stats(self,data):
		"""
		Collects memory statistics.
		"""
		mem_vars = {}
		for field in self.MEM_FIELDS:
			mem_vars[field] = 0L
		try:
			for line in fileinput.input([MEMSTATS_FILE]):
				parts = line.split()
				name = parts[0]
				if name in self.MEM_FIELDS:
					mem_vars[ name] = long( parts[1])
			fileinput.close()
		except IOError:
			return
		self.save_data( data, 'mt', mem_vars[self.MEM_FIELDS[0]])
		self.save_data( data, 'ma', mem_vars[self.MEM_FIELDS[1]])
		self.save_data( data, 'mc', mem_vars[self.MEM_FIELDS[2]])

	def net_stats(self,data):
		"""
		Collects network statistics. Collecting only selected interfaces.
		"""
		receive=0L
		transmit=0L
		try:
			for line in fileinput.input( [NETSTATS_FILE]):
				if line[:5] in NET_DEVICES:
					parts = line.replace( ':', ' ').split()
					receive += long( parts[1])
					transmit += long( parts[9])
			fileinput.close()
		except IOError:
			return

		self.save_data( data, 'ni', receive-self.prev_net_stats[0])
		self.save_data( data, 'no', transmit-self.prev_net_stats[1])
		self.prev_net_stats = [receive, transmit]

	def stats(self):
		"""Collects statistics."""
		data = {}
		self.cpu_stats(data)
		self.disk_stats(data)
		self.mem_stats(data)
		self.net_stats(data)
		return data

	def new_request(self, rq):
		try:
			response = api_request( rq, silent=not config.debug, die_on_error=False)
			if config.debug_stats:
				log.info( response)
		except socket.error, (err_no, err_str):
			pass

	def send_stats(self):
		"""
		Collects all statistics and sends them to Logentries.
		"""
		ethalon = time.time()

		results = self.stats()
		results['request'] = RQ_WORKLOAD
		results['host_key'] = config.agent_key
		if config.debug_stats:
			log.info( results)
		if not self.first:
			# Send data
			self.new_request( results)
		else:
			self.first = False

		ethalon += EPOCH
		next_step = (ethalon-time.time()) % EPOCH
		if not self.to_remove:
			self.timer = threading.Timer( next_step, self.send_stats, ())
			self.timer.daemon = True
			self.timer.start()

	def cancel(self):
		self.to_remove = True
		if self.timer:
			self.timer.cancel()

class Follower(object):
	""" The follower keeps an eye on the file specified and sends new
	events to the logentries infrastructure.  """

	def __init__( self, name, log_key, monitorlogs, event_filter):
		""" Initializes the follower. """
		self.name = name
		self.log_key = log_key
		self.log_addr = '/%s/hosts/%s/%s/?realtime=1'%(config.user_key, config.agent_key, log_key)
		self.flush = True
		self.event_filter = event_filter
		log.info("Following %s"%name)
		monitoring_thread = threading.Thread( target=monitorlogs, name=self.name)
		monitoring_thread.daemon = True
		monitoring_thread.start()

	def file_candidate( self):
		""" Returns list of file names which corresponds to the
		specified template. """
		try:
			candidates = glob.glob( self.name)

			if len(candidates) == 0:
				return None

			candidate_times = [ [os.path.getmtime(name),name] for name in candidates]
			candidate_times.sort()
			candidate_times.reverse()
			return candidate_times[ 0][ 1]
		except os.error:
			return None

	def open_log( self):
		"""Keeps trying to re-open the log file. Returns when the file
		has been opened or when requested to remove."""
		error_info = True
		self.real_name = None

		while not shutdown:
			candidate = self.file_candidate()

			if candidate:
				try:
					self.real_name = candidate
					self.file = open( self.real_name)
					break
				except IOError: pass

			if error_info:
				log.info( "Cannot open file '%s', re-trying in %ss intervals"%(self.name, REOPEN_INT))
				error_info = False
			time.sleep( REOPEN_TRY_INTERVAL)

	def log_rename( self):
		"""Detects file rename."""

		# Get file candidates
		candidate = self.file_candidate()
		if not candidate: return False

		try:
			# This is tricky routine we found during our work on
			# Windows machines which we would like to support. Here
			# we need to detect whether the open log file is the
			# same as file_adept. This is easy in Linux, but not in
			# Windows. What we do now is to compare ctime (creation
			# in Windows and change in Unix) and detect whether
			# those are the same. This works relialibly for log
			# renaming.
			ctime1 = os.fstat( self.file.fileno()).st_mtime
			ctime_new = os.path.getmtime( candidate)
			ctime2 = os.fstat( self.file.fileno()).st_mtime

			if ctime1 == ctime2 and ctime1 != ctime_new:
				# We have a name change according to the time
				return True
		except os.error: pass
		return False

	def read_log_line(self):
		""" Reads a line from the log. Checks maximal line size. """

		return self.file.read( MAX_EVENTS)

	def get_events( self):
		""" Returns a block of newly detected events from the log.
		Returns None in case of timeout. """

		# Moves at the end of the log file
		if self.flush:
			self.file.seek( 0, 2)
			self.flush = False

		# TODO: investigate select-like approach?
		idle_cnt = 0
		iaa_cnt = 0
		events = ''
		while iaa_cnt != IAA_INTERVAL and not shutdown:
			# Collect lines
			events = self.read_log_line()
			#####	print type(events) ##DEBUG
			if len(events) != 0: break

			# No more events, wait
			time.sleep( TAIL_RECHECK)

			# Log rename check
			idle_cnt += 1
			if idle_cnt == NAME_CHECK:
				if self.log_rename():
					self.open_log()
					iaa_cnt = 0
				else:
					# Recover from external file modification
					position = self.file.tell()
					self.file.seek( 0, 2)
					file_size = self.file.tell()
					if file_size < position:
						# File has been externaly modified
						position = file_size
					self.file.seek( position)
				idle_cnt = 0
			else:
				# To reset end-of-line error
				self.file.seek( self.file.tell())
			iaa_cnt += 1

		# Send IAA packet if required
		if iaa_cnt == IAA_INTERVAL:
			return None

		return events
	
	def open_connection(self):
		""" Opens a push connection to logentries. """
		log.debug( "Opening connection %s", self.log_addr)
		retry = 1
		while True:
			if retry % 3 == 0:
				self.flush = True
				time.sleep( SRV_RECON_TIMEOUT)
			retry += 1
			try:
				self.conn = domain_connect()
				do_request( self.conn, "PUT", self.log_addr)
				break
			except socket.error:
				if shutdown: return
	
	def send_events( self, events):
		""" Sends a block of new lines. """
		if events:
			events = self.event_filter( events)
			if not events:
				return
		else:
			events = IAA_TOKEN
		while not shutdown:
			try:
				self.conn.send( events)
				break
			except socket.error, (err_no, err_str):
				self.open_connection()

		if config.debug_events:
			print >>sys.stderr, events,

	
class LogFollower(Follower):

	def __init__(self, name, log_key, event_filter):
		super(LogFollower, self).__init__( name, log_key, self.monitorlogs, event_filter)
	
	def monitorlogs(self):
		""" Opens the log file and starts to collect new events. """
		self.open_connection()
		self.open_log()
		while not shutdown:
			try:
				events = self.get_events()
			except IOError, e:
				if config.debug:
					log.debug( "IOError: %s", e)
				self.open_log()
			self.send_events( events)
	

# Some of the code is from 
# http://docs.activestate.com/activepython/2.4/pywin32/Windows_NT_Eventlog.html
class WinEventFollower(Follower):

	def __init__(self, name, log_key, event_filter):
		super(WinEventFollower, self).__init__( name, log_key, self.monitorlogs, event_filter)
		
	def monitorlogs(self):
		""" Opens the windows event log file and starts to collect new events. """
		self.open_connection()
		self.open_windows_event_log()
	
	def date2sec(self, evt_date):
		'''
		This function converts dates with format
		'12/23/99 15:54:09' to seconds since 1970.
		'''
		regexp = re.compile('(.*)\\s(.*)') #store result in site
		reg_result = regexp.search(evt_date)
		date = reg_result.group( 1)
		the_time = reg_result.group( 2)
		(mon,day,yr) = map( lambda x: int(x),string.split(date,'/'))
		(hr,mins,sec) = map( lambda x: int(x),string.split(the_time,':'))
		tup = [yr,mon,day,hr,mins,sec,0,0,0]

		sec = time.mktime(tup)

		return sec

	def date2output(self, evt_date):
		'''
		This function converts dates with format
		'12/23/99 15:54:09' to the following linux style format '2011-04-22 10:43:58' 
		'''
		regexp = re.compile( '(.*)\\s(.*)') #store result in site
		reg_result = regexp.search( evt_date)
		date=reg_result.group( 1)
		the_time = reg_result.group( 2)
		(mon,day,yr) = map( lambda x: int(x),string.split(date,'/'))
		(hr,mins,sec) = map( lambda x: int(x),string.split(the_time,':'))
		tup = [yr,mon,day,hr,mins,sec,0,0,0]

		return time.strftime( "%Y-%m-%d %H:%M:%S", tup)

	def open_windows_event_log(self):
		server = None # None = local machine
		hand = win32evtlog.OpenEventLog( server, self.name)
		flags = win32evtlog.EVENTLOG_SEQUENTIAL_READ | win32evtlog.EVENTLOG_FORWARDS_READ
		evt_dict = {
			win32con.EVENTLOG_AUDIT_FAILURE: 'EVENTLOG_AUDIT_FAILURE',
			win32con.EVENTLOG_AUDIT_SUCCESS: 'EVENTLOG_AUDIT_SUCCESS',
			win32con.EVENTLOG_INFORMATION_TYPE: 'EVENTLOG_INFORMATION_TYPE',
			win32con.EVENTLOG_WARNING_TYPE: 'EVENTLOG_WARNING_TYPE',
			win32con.EVENTLOG_ERROR_TYPE: 'EVENTLOG_ERROR_TYPE'}

		begin_sec = time.time() # get the current time 
		
		try:		
			while not shutdown:
				eventdata = ''
				events = win32evtlog.ReadEventLog( hand, flags, 0)
				
				while len( events) == 0 and not shutdown:
					time.sleep( TAIL_RECHECK)
 					events = win32evtlog.ReadEventLog( hand, flags, 0)

				for ev_obj in events:

					the_time = ev_obj.TimeGenerated.Format() #'12/23/99 15:54:09'
					event_time = self.date2output( the_time) # convert to '2011-04-22 10:43:58' 
					seconds = self.date2sec( the_time)

					# if message was in the log before we started monitoring disregard
					# only monitor new messages in the log
				
					if seconds < begin_sec: break 

					evt_id = str(winerror.HRESULT_CODE(ev_obj.EventID))
					# FIXME not used
					computer = str(ev_obj.ComputerName)
					cat = ev_obj.EventCategory
					record = ev_obj.RecordNumber
					msg = win32evtlogutil.SafeFormatMessage(ev_obj, self.name)
	
					msg = msg.replace('\r\n','\r')
					msg = msg.encode('utf-8')
					
			 		source = str(ev_obj.SourceName)
					
					if not ev_obj.EventType in evt_dict.keys():
						evt_type = "unknown"
					else:
						evt_type = str(evt_dict[ev_obj.EventType])
					eventdata = "%s %s %s %s %s #%s %s %s\n"%(event_time, computer, cat, evt_id, evt_type, record, source, msg)
					self.send_events( eventdata)
		except:
			print traceback.print_exc(sys.exc_info())

class Config:
	def __init__(self):
		self.config_dir_name = self.get_config_dir()
		self.config_filename = self.config_dir_name +LE_CONFIG

		# Configuration variables
		self.user_key = DEFAULT_USER_KEY
		self.agent_key = NOT_SET
		self.filters = NOT_SET
		self.name = NOT_SET
		self.hostname = NOT_SET
		self.no_timestamps = False
		self.std = False
		self.std_all = False
		self.type_opt = NOT_SET
		self.xlist = False
		self.uuid = False
		self.daemon = False
		self.winservice = False
		self.pid_file = PID_FILE

		#Windows Options
		self.no_defaults = False

		# Special options
		self.yes = False
		self.force = False
		self.ec2eu = False
		self.suppress_ssl = False

		# Debug options

		# Enabled fine-grained logging
		self.debug = False
		# All recognized events are logged
		self.debug_events = False
		# Adapter connects to locahost
		self.debug_local = False
		# Do not collect statistics
		self.debug_nostats = False
		# Collected statistics are logged
		self.debug_stats = False
		# Collect statistics only
		self.debug_stats_only = False
		# Commands passed to server are logged
		self.debug_requests = False
		# Display system information and exit
		self.debug_system = False
		# Display list of logs in the system
		self.debug_loglist = False
		# Force host for api
		self.force_api_host = None

	def get_config_dir(self):
		"""
		Identifies a configuration directory for the current user.
		Always terminated with slash.
		"""
		if os.name == "posix":
			c_dir = OPENSHIFT_DATA_DIR
		else:
			# Running as an ordinary user (Windows)
			try:
				from win32com.shell import shellcon, shell
				# use CSIDL_COMMON_APPDATA so that config files are always in the same location 
				# whether run as user applicaiton or as a windows service
				c_dir = shell.SHGetFolderPath(0, shellcon.CSIDL_COMMON_APPDATA, 0, 0)
				#debug
				#print c_dir

			except ImportError:
				c_dir = os.path.expanduser('~') +'/' +CONFIG_DIR_USER

		return c_dir + '/'

	def clean(self):
		"""
		Wipes out old configuration file. Returns True if successful.
		"""
		try:
			os.remove( self.config_filename)
		except OSError, e:
			if e.errno != 2:
				log.warning( "Error: %s: %s"%(self.config_filename, e.strerror))
				return False
		return True
		

	def basic_setup(self):
		pass

	def load(self):
		"""
		Initializes configuration parameters from the configuration
		file.  Returns True if successful, False otherwise. Does not
		touch already defined parameters.
		"""

		try:
			conf = ConfigParser.SafeConfigParser( {
				USER_KEY_PARAM: '',
				AGENT_KEY_PARAM: '',
				FILTERS_PARAM: '',
				EC2EU_PARAM: '',
				SUPPRESS_SSL_PARAM: '',
			})
			conf.read( self.config_filename)

			# Load parameters
			if self.user_key == NOT_SET:
				new_user_key = conf.get( MAIN_SECT, USER_KEY_PARAM)
				if new_user_key != '':
					self.user_key = new_user_key
			if self.agent_key == NOT_SET:
				new_agent_key = conf.get( MAIN_SECT, AGENT_KEY_PARAM)
				if new_agent_key != '':
					self.agent_key = new_agent_key
			if self.filters == NOT_SET:
				new_filters = conf.get( MAIN_SECT, FILTERS_PARAM)
				if new_filters != '':
					self.filters = new_filters
			new_ec2eu = conf.get( MAIN_SECT, EC2EU_PARAM)
			if new_ec2eu == 'True':
				self.ec2eu = new_ec2eu
			new_suppress_ssl = conf.get( MAIN_SECT, SUPPRESS_SSL_PARAM)
			if new_suppress_ssl == 'True':
				self.suppress_ssl = new_suppress_ssl
		except ConfigParser.NoSectionError:
			return False
		except ConfigParser.NoOptionError:
			return False
		return True

	def save(self):
		"""
		Saves configuration parameters into the configuration file.
		The certification file added as well.
		"""
		try:
			conf = ConfigParser.SafeConfigParser()
			create_conf_dir()
			conf_file = open( self.config_filename, 'wb')
			conf.add_section( MAIN_SECT)
			if self.user_key != NOT_SET:
				conf.set( MAIN_SECT, USER_KEY_PARAM, self.user_key)
			if self.agent_key != NOT_SET:
				conf.set( MAIN_SECT, AGENT_KEY_PARAM, self.agent_key)
			if self.filters != NOT_SET:
				conf.set( MAIN_SECT, FILTERS_PARAM, self.filters)
			if self.ec2eu:
				conf.set( MAIN_SECT, EC2EU_PARAM, 'True')
			if self.suppress_ssl:
				conf.set( MAIN_SECT, SUPPRESS_SSL_PARAM, 'True')
			conf.write( conf_file)
		except IOError, e:
			die( "Error: IO error when writing to config file: %s"%e)

	def check_key(self, key):
		"""
		Checks if the key looks fine
		"""
		return len(key) == KEY_LEN

	def set_user_key(self, value):
		if not self.check_key( value):
			die( 'Error: User key does not look right.')
		self.user_key = value

	def user_key_required(self):
		"""
		Exits with error message if the user key is not defined.
		"""
		if self.user_key == NOT_SET:
			log.info( "User key is required. Enter your login credentials or specify the user key with --account-key parameter.")
			self.user_key = retrieve_user_key()
			config.save()

	def set_agent_key(self, value):
		if not self.check_key( value):
			die( 'Error: Agent key does not look right.')
		self.agent_key = value

	def agent_key_required(self):
		"""
		Exits with error message if the agent key is not defined.
		"""
		if self.agent_key == NOT_SET:
			die( "Agent key is required. Register the host or specify an agent key with the --host-key parameter.")

	def have_agent_key(self):
		"""Tests if the agent key has been assigned to this instance."""
		return self.agent_key != ''

	def hostname_required(self):
		"""
		Sets the hostname parameter based on server network name. If
		the hostname is set already, it is kept untouched.
		"""
		if self.hostname == NOT_SET:
			self.hostname = socket.getfqdn()
		return self.hostname

	def name_required(self):
		"""
		Sets host name if not set already. The new host name is
		delivered from its hostname. As a side effect this
		function sets a hostname as well.
		"""
		if self.name == NOT_SET:
			self.name = self.hostname_required().split('.')[0]
		return self.name

	def detect_ec2eu(self):
		"""
		Detects if this machine is within EC2 EU region. If it is,
		the flag ec2eu is set as well as SSL is suppress.
		"""
		# No need to detect if the flag ec2eu is set already
		if self.ec2eu:
			return

		avz = ''
		socket.setdefaulttimeout( 1)
		try:
			response = urllib2.urlopen( EC2_AVZ_URL)
			avz = response.read( 16)
			response.close()
		except:
			pass
		socket.setdefaulttimeout( None)

		self.ec2eu = avz.startswith( EC2_AVZ_EU_PREFIX)
		self.suppress_ssl = avz != ''

	def process_params(self, params):
		"""
		Parses command line parameters and updates config parameters
		accordingly.
		"""
		try:
			optlist, args = getopt.gnu_getopt( params, '', "user-key= account-key= agent-key= host-key= no-timestamps debug-events debug-loglist local debug-stats debug-nostats debug-stats-only debug-cmds debug-system help version yes force uuid list std std-all name= hostname= type= pid-file= debug no-defaults ec2eu suppress-ssl force-api-host=".split())
		except getopt.GetoptError, err:
			die( "Parameter error: " +str( err));
		for name, value in optlist:
			if name == "--help":
				print_usage()
			if name == "--version":
				print_usage( True)
			if name == "--yes":
				self.yes = True
			elif name == "--user-key":
				self.set_user_key( value)
			elif name == "--account-key":
				self.set_user_key( value)
			elif name == "--agent-key":
				self.set_agent_key( value)
			elif name == "--host-key":
				self.set_agent_key( value)
			elif name == "--force":
				self.force = True
			elif name == "--list":
				self.xlist = True
			elif name == "--uuid":
				self.uuid = True
			elif name == "--name":
				self.name = value
			elif name == "--hostname":
				self.hostname = value
			elif name == "--pid-file":
				if value == '':
					self.pid_file = None
				else:
					self.pid_file = value
			elif name == "--std":
				self.std = True
			elif name == "--type":
				self.type_opt = value
			elif name == "--std-all":
				self.std_all = True
			elif name == "--no-timestamps":
				self.no_timestamps = True
			elif name == "--debug":
				self.debug = True
			elif name == "--debug-events":
				self.debug_events = True
			elif name == "--local":
				self.debug_local = True
			elif name == "--debug-stats":
				self.debug_stats = True
			elif name == "--debug-nostats":
				self.debug_nostats = True
			elif name == "--debug-stats-only":
				self.debug_stats_only = True
			elif name == "--debug-loglist":
				self.debug_loglist = True
			elif name == "--debug-requests":
				self.debug_requests = True
			elif name == "--debug-system":
				self.debug_system = True
			elif name == "--no-defaults":
				self.no_defaults = True
			elif name == "--ec2eu":
				self.ec2eu = True
			elif name == "--suppress-ssl":
				self.suppress_ssl = True
			elif name == "--force-api-host":
                                if value and value != '': self.force_api_host = value
		if self.debug_local and self.force_api_host: die("Please do not specify --local and --force-api-host at the same time.")
		return args


config = Config()

#windows specific imports
if os.name != "posix":

	# winservice.py
	# code adapted from http://code.activestate.com/recipes/551780/

	from os.path import splitext, abspath
	import win32event
	import win32con
	import winerror
	import traceback
	import win32api
	import win32serviceutil
	import win32service
	import win32evtlog		
	import win32evtlogutil

	class Service(win32serviceutil.ServiceFramework):
		_svc_name_ = '_LEService'
		_svc_display_name_ = '_Service Template'
		def __init__(self, *args):
			win32serviceutil.ServiceFramework.__init__(self, *args)
			self.log('init')
			self.stop_event = win32event.CreateEvent(None, 0, 0, None)
		def log(self, msg):
			import servicemanager
			servicemanager.LogInfoMsg(str(msg))
		def sleep(self, sec):
			win32api.Sleep(sec*1000, True)
		def SvcDoRun(self):
			self.ReportServiceStatus(win32service.SERVICE_START_PENDING)
			try:
				self.ReportServiceStatus(win32service.SERVICE_RUNNING)
				self.log('start')
				self.start()
				self.log('wait')
				win32event.WaitForSingleObject(self.stop_event, win32event.INFINITE)
				self.log('done')
			except Exception, x:
				self.log('Exception : %s' % x)
				self.SvcStop()
		def SvcStop(self):
			self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
			self.log('stopping')
			self.stop()
			self.log('stopped')
			win32event.SetEvent(self.stop_event)
			self.ReportServiceStatus(win32service.SERVICE_STOPPED)
		# to be overridden
		def start(self): pass
		# to be overridden
		def stop(self): pass

	def instwinservice(cls, name, display_name, stay_alive=True):
	    '''
		Install a Service
		    
		    cls : the class (derived from Service) that implement the Service
		    name : Service name
		    display_name : the name displayed in the service manager
		    stay_alive : Service will stop on logout if False
	    '''
	    cls._svc_name_ = name
	    cls._svc_display_name_ = display_name or name
	    try:
		module_path=sys.modules[cls.__module__].__file__
	    except AttributeError:
		# maybe py2exe went by
		from sys import executable
		module_path=executable
	    module_file=splitext(abspath(module_path))[0]
	    cls._svc_reg_class_ = '%s.%s' % (module_file, cls.__name__)
	    if stay_alive: win32api.SetConsoleCtrlHandler(lambda x: True, True)
	    try:
		win32serviceutil.InstallService(
			cls._svc_reg_class_,
			cls._svc_name_,
			cls._svc_display_name_,
			startType=win32service.SERVICE_AUTO_START
			)
		print 'Install ok'
	    except Exception, x:
		print str(x)

		
	def stwinservice(cls, name, display_name, stay_alive=True):
	    '''
		Start Service
		    cls : the class (derived from Service) that implement the Service
		    name : Service name
		    display_name : the name displayed in the service manager
		    stay_alive : Service will stop on logout if False
	    '''

	    cls._svc_name_ = name
	    cls._svc_display_name_ = display_name or name
	    try:
		module_path=sys.modules[cls.__module__].__file__
	    except AttributeError:
		# maybe py2exe went by
		from sys import executable
		module_path=executable
	    module_file=splitext(abspath(module_path))[0]
	    cls._svc_reg_class_ = '%s.%s' % (module_file, cls.__name__)
	    if stay_alive: win32api.SetConsoleCtrlHandler(lambda x: True, True)
	    try:
		win32serviceutil.StartService(
			cls._svc_name_
			)
		print 'Start ok'
	    except Exception, x:
		print str(x)


	class WinStart(Service):


	    def start(self):
		self.runflag=True
		self.log("Logentries is alive ...")

		#from win32com.shell import shellcon, shell
		#c_dir = shell.SHGetFolderPath(0, shellcon.CSIDL_COMMON_APPDATA, 0, 0)
		#self.log(c_dir)
		cmd_monitor([])

	    def stop(self):
		self.runflag=False
		self.log("I'm done")

	def installwinservice( args):
	    no_more_args( args)
	    config.load()
	    config.agent_key_required()
	    config.user_key_required()
   	    instwinservice(WinStart, 'Logentries', 'Logentries')


	def startwinservice( args):
	    no_more_args( args)
	    config.load()
	    config.agent_key_required()
	    config.user_key_required()
	    stwinservice(WinStart, 'Logentries', 'Logentries')


def default_cert_file_name():
	"""
	Construct full file name to the default certificate file.
	"""
	return config.config_dir_name +LE_CERT_NAME


def create_conf_dir():
	"""
	Creates directory for the configuration file.
	"""
	# Create logentries config
	try:
		os.makedirs( config.config_dir_name)
	except OSError, e:
		if e.errno != errno.EEXIST:
			if e.errno == errno.EACCES:
				die( "You don't have permission to create logentries config file. Please run logentries agent as root.")
			die( 'Error: %s'%e)


def write_default_cert_file():
	"""
	Writes default certificate file in the configuration directory.
	"""
	create_conf_dir()
	cert_filename = default_cert_file_name()
	f = open( cert_filename, 'wb')
	f.write( authority_certificate)
	f.close()
	

def default_cert_file():
	"""
	Returns location of the default certificate file or None. It tries to write the
	certificate file if it is not there or it is outdated.
	"""
	cert_filename = default_cert_file_name()
	try:
		# If the certificate file is not there, create it
		if not os.path.exists( cert_filename):
			write_default_cert_file()
			return cert_filename

		# If it is there, check if it is outdated
		curr_cert = rfile( cert_filename)
		if curr_cert != authority_certificate:
			write_default_cert_file()
	except IOError:
		# Cannot read/write certificate file, ignore
		return None
	return cert_filename


def system_cert_file():
	"""
	Finds the location of our lovely site's certificate on the system or None.
	"""
	for f in authority_certificate_files:
		if os.path.exists( f):
			return f
	return None

def create_connection( host, port):
	"""
	A simplified version of socket.create_connection from Python 2.6.
	"""
	for addr_info in socket.getaddrinfo( host, port, 0, socket.SOCK_STREAM):
		af, stype, proto, cn, sa = addr_info
		soc = None
		try:
			soc = socket.socket( af, stype, proto)
			soc.connect( sa)
			return soc
		except socket.error:
			if socket:
				soc.close()

	raise socket.error, "Cannot make connection to %s:%s"%(host,port)


class ServerHTTPSConnection(httplib.HTTPSConnection):
	"""
	A slight modification of HTTPSConnection to verify the certificate
	"""

	def __init__(self, server, cert_file):
		if no_ssl:
			httplib.HTTPSConnection.__init__( self, server)
		else:
			self.cert_file = cert_file
			httplib.HTTPSConnection.__init__( self, server, cert_file=cert_file)

	def connect(self):
		if no_ssl:
			return httplib.HTTPSConnection.connect( self)
		sock = create_connection( self.host, self.port)
		try:
			if self._tunnel_host:
				self.sock = sock
				self._tunnel()
		except AttributeError: pass
		self.sock = wrap_socket( sock, ca_certs=self.cert_file, cert_reqs=CERT_REQUIRED)


def make_https_connection( s):
	"""
	Makes HTTPS connection. Tried all available certificates.
	"""
	# Try to connect with system certificate
	try:
		cert_file = system_cert_file()
		if cert_file:
			return ServerHTTPSConnection( s, cert_file)
	except socket.error:
		pass
	
	# Try to connect with our default certificate
	cert_file = default_cert_file()
	if not cert_file:
		die( 'Error: Cannot find suitable CA certificate.')
	return ServerHTTPSConnection( s, cert_file)
	# Pass the exception


def domain_connect(api=True):
	# Find the correct server address
	s = LE_SERVER
	if api:
		if config.force_api_host:
			s = config.force_api_host
		elif config.ec2eu:
			# If on EC2 EU, use shorter path
			s = LE_SERVER_EC2EU_API_DOMAIN
		else:
			s = LE_SERVER_API_DOMAIN

	# Special case for local debugging
	if config.debug_local:
		if api:
			s = LE_SERVER_API_DOMAIN_L
		else:
			s = LE_SERVER_L

	# Connect to server with SSL in untrusted network
	log.debug( 'Connecting to %s', s)

	# Determine if to use SSL for connection
	# Never use SSL for debugging, always use SSL with main server
	use_ssl = True
	if config.debug_local:
		use_ssl = False
	elif api:
		use_ssl = not config.suppress_ssl

	# Pass the connection
	if use_ssl:
		return make_https_connection( s)
	else:
		return httplib.HTTPConnection( s)


def do_request( conn, operation, addr, data=None, headers={}):
	log.debug( 'Domain request: %s %s %s %s'%(operation, addr, data, headers))
	if data:
		conn.request( operation, addr, data, headers=headers)
	else:
		conn.request( operation, addr, headers=headers)


def get_response( operation, addr, data=None, headers={}, silent=False, die_on_error=True, api=True):
	"""
	Returns response from the domain or API server.
	"""
	response = None
	conn = None
	try:
		conn = domain_connect( api)
		do_request( conn, operation, addr, data, headers)
		response = conn.getresponse()
		return response, conn
	except socket.sslerror, msg: # Network error
		if not silent:
			log.info( "SSL error: %s"%msg)
	except socket.error, msg: # Network error
		if not silent:
			log.debug( "Network error: %s"%msg)
	except httplib.BadStatusLine:
		error = "Internal error, bad status line"
		if die_on_error:
			die( error)
		else:
			log.info( error)
		
	return None, None


def api_request( request, required=False, check_status=False, silent=False, die_on_error=True):
	"""
	Processes a request on the logentries domain.
	"""
	# Obtain response
	response,conn = get_response( "POST", LE_SERVER_API, urllib.urlencode( request),
			silent=silent, die_on_error=die_on_error, api=True)

	# Check the response
	if not response:
		if required:
			die( "Error: Cannot process LE request, no response")
		if conn:
			conn.close()
		return None
	if response.status != 200:
		if required:
			die( "Error: Cannot process LE request: (%s)"%response.status)
		conn.close()
		return None

	xresponse = response.read()
	conn.close()
	log.debug( 'Domain response: "%s"'%xresponse)
	try:
		d_response = json_loads( xresponse)
	except ValueError:
		error = 'Error: Invalid response, parse error.'
		if die_on_error:
			die( error)
		else:
			log.info( error)
			d_response = None

	if check_status and d_response['response'] != 'ok':
		error = "Error: %s"%d_response['reason']
		if die_on_error:
			die( error)
		else:
			log.info( error)
			d_response = None

	return d_response


def pull_request( what, params):
	"""
	Processes a pull request on the logentries domain.
	"""
	response = None

	# Obtain response
	addr = '/%s/%s/?%s'%(config.user_key,urllib.quote( what),urllib.urlencode( params))
	response,conn = get_response( "GET", addr)

	# Check the response
	if not response:
		die( "Error: Cannot process LE request, no response")
	if response.status == 404:
		die( "Error: Log not found")
	if response.status != 200:
		die( "Error: Cannot process LE request: (%s)"%response.status)

	while True:
		data = response.read( 65536)
		if len(data) == 0: break
		sys.stdout.write( data)
	conn.close()


def push_request( ilog, data_size, where, params):
	"""
	Processes a push request to the logentries domain.
	"""
	# Obtain response
	addr = '/%s/%s/?%s'%(config.user_key,urllib.quote(where),urllib.urlencode( params))
	try:
		conn = domain_connect()
		do_request( conn, "PUT", addr, headers={CONTENT_LENGTH:'%s'%data_size})

		# Push the file
		to_send = data_size
		while to_send != 0:
			to_read = to_send
			if to_read > 65536:
				to_read = 65536
			data = ilog.read( to_read)
			if len(data) == 0: break
			to_send -= len(data)
			conn.send( data)
		response = conn.getresponse()
		if response.status != 200:
			reason = response.read()
			try:
				d_response = json_loads( reason)
				reason = d_response['reason']
			except ValueError:
				pass
			die( 'Error: ' +reason);
		conn.close()
	except socket.sslerror, msg: # Network error
		log.info( "SSL error: %s"%msg)
	except socket.error, msg: # Network error
		log.info( "Network error: %s"%msg)

	## Check the response
	#if not response:
	#	die( "Error: Cannot process LE request, no response")
	#if response.status != 200:
	#	die( "Error: Cannot process LE request: (%s)"%response.status)



def request( request, required=False, check_status=False, rtype='GET', retry=False):
	"""
	Processes a list request on the API server.
	"""
	noticed = False
	while True:
		# Obtain response
		response,conn = get_response( rtype, urllib.quote('/'+config.user_key+'/'+request), die_on_error=not retry)
		
		# Check the response
		if response:
			break
		if required:
			die( 'Error: Cannot process LE request, no response')
		if retry:
			if not noticed:
				log.info( 'Error: No response from LE, re-trying in %ss intervals'%SRV_RECON_TIMEOUT)
				noticed = True
			time.sleep( SRV_RECON_TIMEOUT)
		else:
			return None

	response = response.read()
	conn.close()
	log.debug( 'List response: %s'%response)
	try:
		d_response = json_loads( response)
	except ValueError:
		die( 'Error: Invalid response (%s)'%response)

	if check_status and d_response['response'] != 'ok':
		die( 'Error: %s'%d_response['reason'])

	return d_response


def no_more_args( args):
	"""
	Exits if there are any arguments given.
	"""
	if len(args) != 0:
		die( "No more than one argument is expected.")



def request_follow( filename, name, type_opt):
	"""
	Creates a new log to follow the file given.
	"""
	config.agent_key_required()
	request = {"request":"new_log",
		"user_key": config.user_key,
		"host_key": config.agent_key,
		"name": name,
		"filename": filename,
		"type": type_opt,
		"follow": "true"}
	api_request( request, True, True)
	log.info( "Will follow %s as %s"%(filename, name))


def request_hosts( logs=False):
	"""
	Returns list of registered hosts.
	"""
	load_logs = 'false'
	if logs:
		load_logs = 'true'
	response = api_request( {
		'request': 'get_user',
		'load_hosts': 'true',
		'load_logs': load_logs,
		'user_key': config.user_key}, True, True);
	return response['hosts']


def expr_match( expr, text):
	"""
	Returns True if the text matches with expression. If the expression
	starts with / it is a regular expression.
	"""
	if expr[0] == '/':
		if re.match( expr[1:], text):
			return True
	else:
		if expr[0:2] == '\/':
			return text == expr[1:]
		else:
			return text == expr
	return False

def uuid_match( uuid, text):
	"""
	Returns True if the uuid given is uuid and it matches to the text.
	"""
	return is_uuid( uuid) and uuid == text;


def find_hosts( expr, hosts):
	"""
	Finds host name among hosts.
	"""
	result = []
	for host in hosts:
		if uuid_match( expr, host['key']) or expr_match( expr, host['name']) or expr_match( expr, host['hostname']):
			result.append( host)
	return result


def log_match( expr, log_item):
	"""
	Returns true if the expression given matches the log. Expression is either
	a simple word or a regular expression if it starts with '/'.

	We perform the test on UUID, log name, and file name.
	"""
	return uuid_match( expr, log_item['key']) or expr_match( expr, log_item['name']) or expr_match( expr, log_item['filename'])


def find_logs( expr, hosts):
	"""
	Finds log name among hosts. The searching expresion have to parts: host
	name and logs name. Both parts are divided by :.
	"""
	# Decode expression
	l = expr.find( ':')
	if l != -1:
		host_expr = expr[0:l]
		log_expr = expr[l+1:]
	else:
		host_expr = '/.*'
		log_expr = expr

	adepts = find_hosts( host_expr, hosts)
	logs = []
	for host in adepts:
		for xlog in host['logs']:
			if log_match( log_expr, xlog):
				logs.append( xlog)
	return logs


#
# Commands
#

def cmd_init( args):
	"""
	Saves variables given to the configuration file. Variables not
	specified are not saved and thus are overwritten with default value.
	The configuration directory is created if it does not exit.
	"""
	no_more_args( args)
	config.user_key_required()
	config.detect_ec2eu()
	config.save()
	log.info( "Initialized")


def cmd_reinit( args):
	"""
	Saves variables given to the configuration file. The configuration
	directory is created if it does not exit.
	"""
	no_more_args( args)
	config.load()
	config.detect_ec2eu()
	config.save()
	log.info( "Reinitialized")


def cmd_register( args):
	"""
	Registers the agent in logentries infrastructure. The newly obtained
	agent key is stored in the configuration file.
	"""
	no_more_args( args)
	config.load()
	if config.agent_key != NOT_SET and not config.force:
		die( "Server already registered. Use --force to override current registration.")
	config.user_key_required()
	config.hostname_required()
	config.name_required()
	config.detect_ec2eu()

	si = system_detect( True)

	request = {"request": "register",
		'user_key': config.user_key,
		'name': config.name,
		'hostname': config.hostname,
		'system': si['system'],
		'distname': si['distname'],
		'distver': si['distver']
		}
	response = api_request( request, True, True)

	config.agent_key = response['host_key']
	config.save()

	log.info( "Registered %s (%s)"%(config.name, config.hostname))

	# Registering logs
	logs = []
	if config.std or config.std_all:
		logs = collect_log_names( si)
	for logx in logs:
		if config.std_all or logx['default'] == '1':
			request_follow( logx['filename'], logx['name'], logx['type'])


def ask_cmd_register( args):
	try:
		import readline
	except ImportError: pass
	if not config.yes:
		resp = None
		try:
			resp = raw_input( '\nHost is not registered. Would you like to register it (Y/n)? ')
		except EOFError: pass
		if resp not in ['', 'y', 'Y']:
			die( "Please register the host first")
	cmd_register( args)

def load_logs():
	"""
	Loads logs from the server and initializes followers.
	"""
	noticed = False
	logs = None
	while not logs:
		resp = request( 'hosts/%s/'%config.agent_key, False, False, retry=True)
		if resp['response'] != 'ok':
			if not noticed:
				log.error( 'Error retrieving list of logs: %s, retrying in %ss intervals'%(resp['reason'],SRV_RECON_TIMEOUT)) 
				noticed = True
			time.sleep( SRV_RECON_TIMEOUT)
			continue
		logs = resp['list']
		if not logs:
			time.sleep( SRV_RECON_TIMEOUT)

	available_filters = {}
	if config.filters != NOT_SET:
		sys.path.append( config.filters)
		try:
			import filters
			available_filters = filters.filters
		except ImportError:
			log.error( 'Cannot import event filters from %s', config.filters)
		except:
			log.exception( 'Cannot load event filters from %s', config.filters)

	# Start followers
	for l in logs:
		if l['follow'] == 'true':
			log_name = l['name']
			log_key = l['key']

			# Check filters
			event_filter = available_filters.get( log_name)
			if not event_filter:
				event_filter = available_filters.get( log_key)
			if event_filter and not hasattr( event_filter, '__call__'):
				event_filter = None
			if not event_filter:
				event_filter = filter_events

			# Instantiate the follower
			if 'logtype' in l and l['logtype'] == WINEVENT_LOGTYPE: # UUID of type windowseventlogs
				WinEventFollower( l['filename'], l['key'], event_filter)
			else:
				LogFollower( l['filename'], log_key, event_filter)

def is_followed( filename):
	"""
	Checks if the file given is followed.
	"""
	host = request( 'hosts/%s/'%config.agent_key, True, True)
	logs = host['list']
	for ilog in logs:
		if ilog['follow'] == 'true' and filename == ilog['filename']:
			return True
	return False


def cmd_monitor( args):
	"""
	Monitors host activity and sends events collected to logentries
	infrastructure.
	"""
	no_more_args( args)
	config.load()
	if config.agent_key == NOT_SET:
#		ask_cmd_register( args)
		die("Please register the host first with command `le register'")
	config.agent_key_required()
	config.user_key_required()

	if config.daemon:
		daemonize()

	# Register resource monitoring
	stats = Stats()

	try:
		# Load logs to follow
		if not config.debug_stats_only:
			load_logs()

		# Park this thread
		while True:
			time.sleep( 600)
	except KeyboardInterrupt:
		if stats: stats.cancel()
		set_shutdown()

def cmd_monitor_daemon( args):
	"""
	Monitors as a daemon host activity and sends events collected to
	logentries infrastructure.
	"""
	config.daemon = True
	cmd_monitor( args)


def cmd_win_service( args):
	"""
	Monitors as a windows service and sends events collected to
	logentries infrastructure.
	"""
	startwinservice( args)

def cmd_follow_win_events( args):
	"""
	Follow the windows event logs: Application, Security, System
	"""
	if len(args) == 1:
		follow_given_win_event( args[0] )
	elif len(args) != 0:
		die( "Error: Too many arguments.")
	else:
		config.load()
		config.agent_key_required()

		type_opt = "windowseventlogs"
		request_follow( "Application", "Application", type_opt)
		request_follow( "System", "System", type_opt)
		request_follow( "Security", "Security", type_opt)

def follow_given_win_event( event_name ):
	"""
	Follow a specific windows event
	"""
	config.load()
	config.agent_key_required()
	
	type_opt = "windowseventlogs"
	request_follow( event_name, event_name, type_opt)


def cmd_install_win_service( args):
	"""
	Installs a windows service
	"""
	
	config.load()

	if len(args) != 0:
		die( "Error: Too many arguments.")

	installwinservice( args)

	#checks no-default flag
	if not config.no_defaults:
		cmd_follow_win_events( args)



def cmd_follow( args):
	"""
	Follow the log file given.
	"""
	if len(args) == 0:
		die( "Error: Specify the file name of the log to follow.")
	if len(args) != 1:
		die( "Error: Too many arguments.")
	config.load()
	config.agent_key_required()

	filename = os.path.abspath( args[0])
	name = config.name
	if name == NOT_SET:
		name = os.path.basename( filename)
	type_opt = config.type_opt
	if type_opt == NOT_SET:
		type_opt = ""
	
	# Check that we don't follow that file already
	if not config.force and is_followed( filename):
		die( 'Already following %s'%filename)

	if len(glob.glob(filename)) == 0:
		log.warning('\nWARNING: File %s does not exist'%filename)


	request_follow( filename, name, type_opt)



def cmd_followed( args):
	"""
	Check if the log file given is followed.
	"""
	if len(args) == 0:
		die( "Error: Specify the file name of the log to test.")
	if len(args) != 1:
		die( "Error: Too many arguments. Only file name needed.")
	config.load()
	config.agent_key_required()

	filename = os.path.abspath( args[0])
	
	# Check that we don't follow that file already
	if is_followed( filename):
		print 'Following %s'%filename
		sys.exit( EXIT_OK)
	else:
		print 'NOT following %s'%filename
		sys.exit( EXIT_NO)


def cmd_clean( args):
	"""
	Wipes out old configuration file.
	"""
	no_more_args( args)
	if config.clean():
		log.info( 'Configuration clean')


def cmd_whoami( args):
	"""
	Displays information about this host.
	"""
	config.load()
	config.agent_key_required()
	no_more_args( args)

	list_object( request( 'hosts/%s'%config.agent_key, True, True))
	print ''
	list_object( request( 'hosts/%s/'%config.agent_key, True, True))


def get_all_list( what):
	return api_request( {"request":"list_"+what,
		"user_key": config.user_key}, True, True)['list']


def get_all_clusters(): return get_all_list( 'clusters')
def get_all_apps(): return get_all_list( 'apps')
def get_all_salogs(): return get_all_list( 'salogs')

def logtype_name( logtype_uuid):
	response = request( 'logtypes', True, True)
	all_logtypes = response[ 'list']
	for logtype in all_logtypes:
		if logtype_uuid == logtype['key']:
			return logtype['shortcut']
	return 'unknown'

def list_object( request, hostnames=False):
	"""
	Lists object request given.
	"""
	t = request['object']
	index_name = 'name'
	item_name = ''
	if t == 'rootlist':
		item_name = 'item'
		pass
	elif t == 'host':
		print 'name =', request[ 'name']
		print 'hostname =', request[ 'hostname']
		print 'key =', request[ 'key']
		print 'distribution =', request[ 'distname']
		print 'distver =', request[ 'distver']
		return
	elif t == 'log':
		print 'name =', request[ 'name']
		print 'filename =', request[ 'filename']
		print 'key =', request[ 'key']
		print 'type =', request[ 'type']
		print 'follow =', request[ 'follow']
		if 'logtype' in request:
			print 'logtype =', logtype_name( request[ 'logtype'])
		return
	elif t == 'list':
		print 'name =', request[ 'name']
		return
	elif t == 'hostlist':
		item_name = 'host'
		if hostnames:
			index_name = 'hostname'
		pass
	elif t == 'logtype':
		print 'title =', request[ 'title']
		print 'description =', request[ 'desc']
		print 'shortcut =', request[ 'shortcut']
		return
	elif t == 'loglist':
		item_name = 'log'
		pass
	elif t == 'applist':
		item_name = 'app'
		pass
	elif t == 'clusterlist':
		item_name = 'cluster'
		pass
	elif t == 'logtypelist':
		item_name = 'logtype'
		index_name = 'shortcut'
		pass
	else:
		die( 'Unknown object type "%s". Agent too old?'%t)
	
	# Standard list, print it sorted
	ilist = request['list']
	ilist = sorted( ilist, key=lambda item: item[index_name])
	for item in ilist:
		if config.uuid:
			print item['key'],
		print "%s"%(item[ index_name])
	print_total( ilist, item_name)


def cmd_clusters( args):
	"""
	Lists all available clusters.
	"""
	no_more_args( args)
	config.load()
	config.user_key_required()
	clusters = get_all_clusters()

	if config.xlist:
		hosts = request_hosts()
		key2host = {}
		for host in hosts:
			key2host[host['key']] = host
		for cluster in clusters:
			chosts = (key2host[chost]['name'] for chost in cluster['list'])
			print "%s  %s"%(cluster['name'], ', '.join( chosts))
	else:
		print ', '.join( cluster['name'] for cluster in clusters)

	print_total( clusters, 'cluster')

def get_cluster_params( args):
	"""
	Common code for new and set cluster commands. First parameter is
	a cluster name. Following parameters are host uuids, names, or
	hostnames identifying host to assign. Host names or hostnames
	are converted to uuid.
	"""
	if len(args) == 0:
		die( "Error: Specify the cluster name.")
	if re.search( r' ', args[0]):
		die( "Error: Name must not contain space.")
	config.load()
	config.user_key_required()
	skeys = []
	if len(args) > 1:
		hosts = request_hosts()
		log.debug( "Matching hosts to the cluster:")
		for name in args[1:]:
			if len(name) == 0:
				die( "Error: Host name is empty.")
			if is_uuid( name):
				skeys.append( name)
				log.debug( '\t%s as UUID'%name)
			else:
				# Find name among servers
				matches = find_hosts( name, hosts)
				if len(matches) == 0:
					die( "Error: No host matches '%s'."%name)
				else:
					log.debug( "\t%s:"%name)
					for h in matches:
						skeys.append( h['key'])
						log.debug( '\t%s / %s, %s'%(h['key'], h['name'], h['hostname']))
		skeys = uniq( skeys)
		if config.debug:
			log.debug( "Adding following hosts:")
			for key in skeys:
				log.debug( '\t'+key)
	result = [args[0]]
	result.extend( skeys)
	return result


def cmd_new_cluster( args):
	"""
	Creates a new cluster.
	"""
	argv = get_cluster_params( args)
	response = api_request( {
		'request': 'new_clusters',
		'user_key': config.user_key,
		'names': argv[0]}, True, True)
	cluster_key = response['clusters'][0]['key']
	if len(argv) > 1:
		api_request( {
			'request': 'set_cluster',
			'cluster_key': cluster_key,
			'list': ' '.join(argv[1:])}, True, True)
	report( "%s cluster registered"%argv[0])


def cmd_set_cluster( args):
	"""
	Sets cluster attributes.
	"""
	argv = get_cluster_params( args)
	name = argv[0]
	cluster_key = None
	for cluster in get_all_clusters():
		if cluster['name'] == name:
			cluster_key = cluster['key']
			break
	if cluster_key == None:
		die( 'Error: Cluster with name "%s" not found'%name)

	request = {
		'request': 'set_cluster',
		'cluster_key': cluster_key}
	if config.name:
		name = request['name'] = config.name
	if len(argv) > 1:
		request['list'] = ' '.join(argv[1:]);
	api_request( request, True, True)

	report( "%s cluster set"%name)


def cmd_apps( args):
	"""
	Lists all available apps.
	"""
	no_more_args( args)
	config.load()
	config.user_key_required()
	apps = get_all_apps()

	if config.xlist:
		hosts = request_hosts( logs=True)
		key2hostlog = {}
		for host in hosts:
			for xlog in host['logs']:
				key2hostlog[xlog['key']] = host['name']+':'+xlog['name']
		for app in apps:
			alogs = (key2hostlog[clog] for clog in app['list'])
			if config.uuid:
				print app['key'],
			print "%s  %s"%(app['name'], ', '.join( alogs))
	else:
		if config.uuid:
			for app in apps:
				print app['key'] +' ' +app['name']
		else:
			print ', '.join( app['name'] for app in apps)

	print_total( apps, 'app')

def get_app_params( args):
	"""
	Common code for new and set app commands. First parameter is an app
	name. Following parameters are log uuids, or server+log names, or
	hostnames identifying log to assign.
	"""
	if len(args) == 0:
		die( "Error: Specify the app name.")
	if re.search( r' ', args[0]):
		die( "Error: Name must not contain space.")
	config.load()
	config.user_key_required()
	skeys = []
	if len(args) > 1:
		hosts = request_hosts( logs=True)
		log.debug( "Matching logs to the app:")
		for name in args[1:]:
			if len(name) == 0:
				die( "Error: Log name is empty.")
			if is_uuid( name):
				skeys.append( name)
				log.debug( '\t%s as UUID'%name)
			else:
				# Find name among servers
				matches = find_logs( name, hosts)
				if len(matches) == 0:
					die( "Error: No log matches '%s'."%name)
				else:
					log.debug( "\t%s:"%name)
					for l in matches:
						skeys.append( l['key'])
						log.debug( '\t%s / %s, %s'%(l['key'], l['name'], l['filename']))
		skeys = uniq( skeys)
		if config.debug:
			log.debug( "Adding following logs:")
			for key in skeys:
				log.debug( '\t'+key)
	result = [args[0]]
	result.extend( skeys)
	return result


def is_log_fs( addr):
	log_addrs = [ r'(logs|apps)/.*/',
		r'host(name)?s/.*/.*/']
	for la in log_addrs:
		if re.match( la, addr):
			return True
	return False


def cmd_new_app( args):
	"""
	Creates a new application.
	"""
	argv = get_app_params( args)
	response = api_request( {
		'request': 'new_apps',
		'user_key': config.user_key,
		'names': argv[0]}, True, True)
	app_key = response['apps'][0]['key']
	if len(argv) > 1:
		api_request( {
			'request': 'set_app',
			'app_key': app_key,
			'list': ' '.join(argv[1:])}, True, True)
	report( "%s app registered"%argv[0])


def cmd_set_app( args):
	"""
	Sets app attributes.
	"""
	argv = get_app_params( args)
	name = argv[0]
	app_key = None
	for app in get_all_apps():
		if app['name'] == name:
			app_key = app['key']
			break
	if app_key == None:
		die( 'Error: App with name "%s" not found'%name)

	request = {
		'request': 'set_app',
		'app_key': app_key}
	if config.name:
		name = request['name'] = config.name
	if len(argv) > 1:
		request['list'] = ' '.join(argv[1:]);
	api_request( request, True, True)

	report( "%s app set"%name)


def cmd_ls( args):
	"""
	General list command
	"""
	if len(args) == 0:
		args = ['/']
	config.load()
	config.user_key_required()

	addr = args[0]
	if addr.startswith( '/'):
		addr = addr[1:]
	# Make sure we are not downloading log
	if is_log_fs( addr):
		die( 'Use pull to get log content.')
	
	#if addr.count('/') > 2:
	#	die( 'Path not found')
	list_object( request( addr, True, True), hostnames=addr.startswith('hostnames'))

def cmd_rm( args):
	"""
	General remove command
	"""
	if len(args) == 0:
		args = ['/']
	config.load()
	config.user_key_required()

	addr = args[0]
	if addr.startswith( '/'):
		addr = addr[1:]
	if addr.count('/') > 2:
		die( 'Path not found')
	response = request( addr, True, True, rtype='DELETE')
	report( response['reason'])


def cmd_pull( args):
	"""
	Log pull command
	"""
	if len(args) == 0:
		die( PULL_USAGE)
	config.load()
	config.user_key_required()

	params = {}

	addr = args[0]
	if addr.startswith( '/'):
		addr = addr[1:]
	if addr.endswith( '/'):
		addr = addr[:-1]
	if not is_log_fs( addr+'/'):
		die( 'Error: Not a log')

	if len(args) > 1:
		time_range = parse_timestamp_range( args[ 1])
		params['start'] = time_range[ 0]
		params['end'] = time_range[ 1]
	if len(args) > 2:
		params['filter'] = args[ 2]
	if len(args) > 3:
		try: params['limit'] = int( args[ 3])
		except ValueError: die( 'Error: Limit must be integer')
	
	pull_request( addr, params)


def cmd_push( args):
	"""
	Log push command
	"""
	if len(args) < 2:
		die( PUSH_USAGE)
	config.load()
	config.user_key_required()

	filename = args[0]

	addr = args[1]
	if addr.startswith( '/'):
		addr = addr[1:]
	if addr.endswith( '/'):
		addr = addr[:-1]
	if not is_log_fs( addr+'/'):
		die( 'Error: Not a suitable log path')

	params = {}
	if len(args) > 2:
		params['logtype'] = args[ 2]
	
	try:
		data_size = os.path.getsize( filename)
		logfile = open( filename, "r")
	except OSError:
		die( "Error: Cannot open '%s'"%filename)
	except IOError:
		die( "Error: Cannot open '%s'"%filename)

	push_request( logfile, data_size, addr, params)

#
# Main method
#
	
def main():
	# Read command line parameters
	args = config.process_params( sys.argv[1:])

	if config.debug:
		log.setLevel( logging.DEBUG)
	if config.debug_system:
		die( system_detect( True))
	if config.debug_loglist:
		die( collect_log_names( system_detect( True)))

	argv0 = sys.argv[0]
	if argv0 and argv0 != '':
		pname = os.path.basename( argv0).split( '-')
		if len(pname) != 1:
			args.insert( 0, pname[-1])

	if len(args) == 0:
		report( USAGE)
		if os.name != "posix":
			report( WINDOWS_USAGE)
		sys.exit( EXIT_HELP)

	commands = {
		'init': cmd_init,
		'reinit': cmd_reinit,
		'register': cmd_register,
		'monitor': cmd_monitor,
		'monitordaemon': cmd_monitor_daemon,
		'follow': cmd_follow,
		'followed': cmd_followed,
		'clean': cmd_clean,
		'whoami': cmd_whoami,
		# Windows
		'monitorwinservice': cmd_win_service,
		'installwinservice': cmd_install_win_service,
		'windowsevents': cmd_follow_win_events,
		# Clusters
		#'new-cluster': cmd_new_cluster,
		#'set-cluster': cmd_set_cluster,
		# Apps
		#'new-app': cmd_new_app,
		#'set-app': cmd_set_app,
		# Filesystem operations
		'ls': cmd_ls,
		'rm': cmd_rm,
		'pull': cmd_pull,
		'push': cmd_push,
		# Shortcuts
		#'nc': cmd_new_cluster,
		#'sc': cmd_set_cluster,
		#'na': cmd_new_app,
		#'sa': cmd_set_app,
	}
	for cmd, func in commands.items():
		if cmd == args[0]:
			return func( args[1:])
	die( 'Error: Unknown command "%s".'%args[0])


if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		log.info( "Interrupted")


# For Debian Lenny you will need to install ssl:
# aptitude install python-dev libbluetooth-dev
# http://pypi.python.org/pypi/ssl#downloads
# python setup install.py

#
# Windows event logs:
# http://www.blog.pythonlibrary.org/2010/07/27/pywin32-getting-windows-event-logs/
#
