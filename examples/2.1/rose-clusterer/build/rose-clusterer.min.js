(function (global){
var ym = { modules: global.ymaps.modules };
ymaps.modules.define('RoseClusterer', [
    'util.defineClass',
    'util.extend',
    'Clusterer',
    'GeoObjectCollection'
], function (provide, defineClass, extend, Clusterer, GeoObjectCollection) {

var RoseClusterer = defineClass(
    function (options) {
        RoseClusterer.superclass.constructor.call(
            this,
            extend({
                radius: 30,
                hasBalloon: false
            }, options)
        );
    }, Clusterer, {
        createCluster: function (center, geoObjects) {
            var map = this.getMap(),
                zoom = map.getZoom(),
                maxZoom = map.zoomRange.getCurrent()[1];

            if(zoom >= maxZoom) {
                 return this._createRoseCollection(center, geoObjects);
            }
            else {
                return RoseClusterer.superclass.createCluster.call(this, center, geoObjects);
            }
        },
        _createRoseCollection: function (center, geoObjects) {
            var collection = new GeoObjectCollection({
                properties: { center: center }
            });

            geoObjects.forEach(collection.add, collection);

            collection.events.once('mapchange', this._onRoseCollectionMapChange, this);

            return collection;
        },
        _onRoseCollectionMapChange: function (e) {
            var collection = e.get('target'),
                center = collection.properties.get('center'),
                num = collection.getLength(),
                radius = this.options.get('radius');

            collection.each(function (geoObject, index) {
                var angle = Math.PI * 2 / num * (num - index),
                    offset = this._getGeoObjectOffset(center, geoObject);

                geoObject.getOverlay()
                    .then(function (overlay) {
                        overlay.options.set('offset', [
                            offset[0] + Math.sin(angle) * radius,
                            offset[1] + Math.cos(angle) * radius
                        ]);
                    }, function (err) {
                        console.log(err);
                    });
            }, this);
        },
        _getGeoObjectOffset: function (center, geoObject) {
            var map = this.getMap(),
                zoom = map.getZoom(),
                projection = map.options.get('projection'),
                pixelCenter = projection.toGlobalPixels(center, zoom),
                coordinates = geoObject.geometry.getCoordinates(),
                pixelCoordinates = projection.toGlobalPixels(coordinates, zoom);

            return [
                pixelCenter[0] - pixelCoordinates[0],
                pixelCenter[1] - pixelCoordinates[1]
            ];
        }
    });

    provide(RoseClusterer);
});

ym.modules.define('RandomPointsGenerator', [
    'coordSystem.geo'
], function (provide, coordSystem) {
    /**
     * Random-генератор меток.
     * @class
     * @name RandomPointsGenerator
     * @param {Number} count Количество меток которые надо создать.
     * @example
     var placemarks = RandomPointsGenerator.generate(200).atBounds(myMap.getBounds());
     */
    function RandomPointsGenerator(count) {
        this.count = count || 0;
    }

    /**
     * Статический метод для удобства инстанцирования.
     * @static
     * @function
     * @name RandomPointsGenerator.generate
     * @param {Number} count Количество меток которые надо создать.
     * @returns {RandomPointsGenerator} Экземпляр генератора меток.
     */
    RandomPointsGenerator.generate = function (count) {
        return new RandomPointsGenerator(count);
    };

    /**
     * Устанавливает количество меток для генерации.
     * @function
     * @name RandomPointsGenerator.generate
     * @param {Number} count Количество меток которые надо создать.
     * @returns {RandomPointsGenerator} Экземпляр генератора меток.
     */
    RandomPointsGenerator.prototype.generate = function (count) {
        this.count = count;

        return this;
    };

    /**
     * Генерит случайным образом метки в области bounds.
     * @function
     * @name RandomPointsGenerator.atBounds
     * @param {Number[][]} bounds Область видимости меток.
     * @returns {ymaps.Placemark[]} Массив меток.
     */
    RandomPointsGenerator.prototype.atBounds = function (bounds) {
        // протяженность области просмотра в градусах
        var span = [bounds[1][0] - bounds[0][0], bounds[1][1] - bounds[0][1]],
            points = [];

        for(var i = 0; i < this.count; i++) {
            points[i] = this.createPlacemark([Math.random() * span[0] + bounds[0][0], Math.random() * span[1] + bounds[0][1]], i);
        }

        return points;
    };

    /**
     * Генерит случайным образом метки внутри окружности с данным центром и радиусом.
     * @function
     * @name RandomPointsGenerator.atCenterAndRadius
     * @param {Number[]} center Координаты центра окружности.
     * @param {Number} radius Радиус окружности в метрах.
     * @returns {ymaps.Placemark[]} Массив меток.
     */
    RandomPointsGenerator.prototype.atCenterAndRadius = function (center, radius) {
        var distance, direction, coords, points = [];

        for(var i = 0; i < this.count; i++) {
            direction = [Math.random() - Math.random(), Math.random() - Math.random()];
            distance = radius * Math.random();
            coords = coordSystem.solveDirectProblem(center, direction, distance).endPoint;
            points[i] = this.createPlacemark(coords, i);
        }

        return points;
    };

    /**
     * TODO
     * Генерит случайным образом метки внутри области с данным центром и линейными размерами.
     * @function
     * @name RandomPointsGenerator.atCenterAndSize
     * @param {Number[]} center Координаты центра области.
     * @param {Number[]} size Линейные размеры области в метрах.
     * @returns {ymaps.Placemark[]} Массив меток.
     */
    RandomPointsGenerator.prototype.atCenterAndSize = function (center, size) {};

    /**
     * Создает метку по координатам.
     * @function
     * @name RandomPointsGenerator.createPlacemark
     * @param {Number[]} coordinates Массив координат.
     * @param {Number} index Индекс метки.
     * @returns {ymaps.Placemark} Метка.
     */
    RandomPointsGenerator.prototype.createPlacemark = function (coordinates, index) {
        return new ymaps.GeoObject({
            geometry: {
                type: "Point",
                coordinates: coordinates
            },
            properties: this.getPointData(index)
        }, this.getPointOptions(index));
    };

    /**
     * Метод для перекрытия. Возвращает объект с данными,
     * который передается как поле properties в конструктор геообъекта.
     * @function
     * @name RandomPointsGenerator.getPointData
     * @param {Number} index Индекс метки.
     * @returns {Object} Данные метки.
     */
    RandomPointsGenerator.prototype.getPointData = function (index) {
        return {};
    };

    /**
     * Метод для перекрытия. Возвращает объект с опциями,
     * который передается как параметр options в конструктор геообъекта.
     * @function
     * @name RandomPointsGenerator.getPointOptions
     * @param {Number} index Индекс метки.
     * @returns {Object} Опции метки.
     * @example
     var generator = RandomPointsGenerator.generate(200);

     // Перекрываем метод для создания меток со случайным хначением опции preset.
     generator.getPointOptions = function (i) {
         var presets = ['islands#blueIcon', 'islands#orangeIcon', 'islands#darkblueIcon', 'islands#pinkIcon'];

         return {
             preset: presets[Math.floor(Math.random() * presets.length)]
         };
     };
     */
    RandomPointsGenerator.prototype.getPointOptions = function (index) {
        return {};
    };

    provide(RandomPointsGenerator);
});


(function (modules){
var project = { DEBUG: false };
if (typeof modules == 'undefined' && typeof require == 'function') {
    var modules = require('ym');
}

modules.define('util.providePackage', ['system.mergeImports'], function (provide, mergeImports) {
    provide(function (srcPackage, packageArgs) {
        var packageProvide = packageArgs[0],
            packageModules = Array.prototype.slice.call(packageArgs, 1),
            ns = mergeImports.joinImports(srcPackage.name, {}, srcPackage.deps, packageModules);

        packageProvide(ns);
    });
});
})(ym.modules);

})(this);